<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tidbits | Confessions of a Wall Street Programmer]]></title>
  <link href="http://btorpey.github.io/blog/categories/tidbits/atom.xml" rel="self"/>
  <link href="http://btorpey.github.io/"/>
  <updated>2014-05-22T09:57:53-04:00</updated>
  <id>http://btorpey.github.io/</id>
  <author>
    <name><![CDATA[Bill Torpey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Visualizing Latency]]></title>
    <link href="http://btorpey.github.io/blog/2014/05/16/visualizing-latency/"/>
    <updated>2014-05-16T08:42:58-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/05/16/visualizing-latency</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/ping.png" width="320" height="240"> 

I'm a visual thinker (I think I may have [mentioned that before](http://btorpey.github.io/blog/2014/04/29/a-picture-is-worth-1k-words/) ),
so when I'm analyzing performance, latency, etc. I find it really helpful to be
able to visualize what is going on on the machine. 

As a result, I had gotten
reasonably good at using Excel to produce charts, which sometimes helped to correlate observed
behaviors like latency spikes with other events on the machine.

For a bunch of reasons I wanted to move away from Excel, though, and find
another tool that would give me the same or better functionality.

<!--more-->

For one thing, a little over a year ago I switched to a Mac as my main machine
after years of using Windows. There was a certain amount of adjustment, but for
the most part it's been smooth sailing. More than that, I was actually able to
recapture some of the fun and excitement I remember from my first Apple (an
Apple ][).

I also wanted something that would run on both the Mac and Linux, where I do
most of my testing. Last but not least, I wanted something that would be
scriptable so I could easily produce consistent charts for multiple test runs.

I looked briefly at R, but ditched it when it used up all the 8GB in my laptop,
plus the entire hard disk as swap, for a single dataset of 100,000 points.
Probably my bad, but I didn't have the patience to figure out what I might be
doing wrong.

At that point I turned to venerable (some would say crusty) gnuplot. It's a bit
long in the tooth, but I just wanted to plot latency over time, so how hard
could that be? Well, I guess it's pretty easy if you already know how, but
starting from scratch is another story.

Which brings me to my rant of the day, directed at techies in general, and to the
(us?) Linux/Unix techies in particular.

Short version: I don't want to learn gnuplot. I don't even want to *have
learned* gnuplot -- even if I could do that by just taking a pill. What I want
is to be able to produce decent-looking charts *without* knowing *anything*
about gnuplot.

> When all else fails, read the instructions.

To be fair, the gnuplot docs did have some examples -- more anyway than you
would find in a typical man page, although that's admittedly a low bar. And
while my google-fu is usually pretty good, I just couldn't find anything on the
intertubes that would work for me, so I had to learn *just a little* gnuplot.

It turns out that gnuplot works pretty well, and will probably work even better
once I learn (sigh) how to use it better.

But you don't have to learn diddly if you don't want to. [Here is the first](<https://github.com/btorpey/latency-utils.git>) in
what will hopefully be a series of recipes that you can use with little or no
modification.  Once you've downloaded the repo, enter the following at the command prompt:

`./tsd.sh ping.csv x11`

Which should result in something like this:

<img class="center" src="/images/gnuplot.png"> 

It's primitive, but that very primitiveness has its own appeal, especially for
those of us for whom "UI" means bash, vi or emacs.

A couple of points about the gnuplot command files:

-   Sometimes you care about the actual time that an event took place, so you
can correlate it with some other event; sometimes you don't. Accordingly, I've
created two different files: one which displays actual time (ts.gp), the other
which calculates and displays deltaT (tsd.gp).

-   I've been programming in C (and later C++) for many years, but I don't think
I've ever purposely used the comma operator before. Well, expressions in gnuplot
follow C language rules for operators, precedence, etc. and that comma operator
turns out to be handy -- in this case it lets us 
update the origin in the same expression that calculates deltaT.
(The return value of the comma
operator is the right-hand expression).

-- (Note that the above requires something like gnuplot 4.6)


-   I've left the default terminal in the gnuplot command files, but you can 
specify a different one on the command line.  To get a list of terminals supported 
in your version:
`gnuplot -e "set terminal"`.

Comments, suggestions, pull requests, etc. welcome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Picture is Worth 1K Words]]></title>
    <link href="http://btorpey.github.io/blog/2014/04/29/a-picture-is-worth-1k-words/"/>
    <updated>2014-04-29T19:23:07-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/04/29/a-picture-is-worth-1k-words</id>
    <content type="html"><![CDATA[<p>You know those mutiple-choice tests that put you in one of four quadrants based
on your answers to a bunch of seemingly irrelevant questions? We've all taken
them, and if you're like me they're kind of like reading your horoscope -- it
all seems so right and true when you're reading it, but you wonder if it would
still seem just as right and true if the horoscopes got jumbled at random?

Well, I took one of these tests a while back that actually told me something about myself -- it was the "Learning-Style Inventory"
test, and what it said about me is that I'm waaaayyy over at the end of the
scale when it comes to visual thinking. That gave me an insight into the way my
brain works that I've found really helpful ever since. So, this next bit was right up my alley,
but I'm guessing you'll like it too.

[<img class="right" src="http://overbyte.com.au/wp-content/uploads/2012/01/InteractiveMemAccess-620x424.png" width="320" height="240">](<http://www.overbyte.com.au/misc/Lesson3/CacheFun.html>)

We read a lot lately about NUMA architecture and how it presents a fundamental
change in the way we approach writing efficient code: it's no longer about the
CPU, it's all about RAM. We all nod and say "Sure, I get that!"  Well, I thought
I got it too, but until I saw [this web page](<http://www.overbyte.com.au/misc/Lesson3/CacheFun.html>), 
I really didn't. 

See the full discussion at <http://overbyte.com.au/index.php/overbyte-blog/entry/optimisation-lesson-3-the-memory-bottleneck>.
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You may ask yourself - "How did I get here?"]]></title>
    <link href="http://btorpey.github.io/blog/2014/02/13/how-did-i-get-here/"/>
    <updated>2014-02-13T18:02:27-05:00</updated>
    <id>http://btorpey.github.io/blog/2014/02/13/how-did-i-get-here</id>
    <content type="html"><![CDATA[<p>In addition to being a great line from David Byrne and Talking Heads (from "Life
During Wartime"), this is also a question I often ask myself when
looking at log files. Today's tip is worth the price of the whole blog (i.e.,
free), but I predict that you'll be glad you know it.

<!--more-->

It's pretty common to pipe the output of a command, or string of commands, to a
file to have a record of what happened when executing the command, something
like this:

`big_gnarly_command_line_with_options 2>&1 | tee logfile.out`

That works great for capturing the *output* of the command, but what about the
big_gnarly_command_line_with_options itself?

Try this instead:

` bash -x -c "big_gnarly_command_line_with_options" 2>&1 | tee logfile.out`


Now, your output file will look like this:

`+ big_gnarly_command_line_with_options`<br>
`... output of big_gnarly_command_line_with_options ...`

If your gnarly command is actually several gnarly commands, enclose the whole
gnarly list in parentheses and separate with semicolons (or &&), like so:

` bash -x -c "(big_gnarly_command_line_with_options_1;
big_gnarly_command_line_with_options_2)" 2>&1 | tee logfile.out`

Normal quoting rules apply:

-   If you enclose the command(s) in double-quotes ("), variable substitution
    will be done on the command line

-   If you need to include a double-quote within double-quotes, you need to
    escape it (with the backslash (\\) character)

-   If you enclose the command line(s) in single quotes ('), no variable
    substitution is done

-   There is no way to include a single-quote within single-quotes, but there is
    a trick that gives a similar effect, that you can read about here (<http://stackoverflow.com/a/1250279/203044>).

Now you'll never need to ask yourself "How did I get here"?

  
  

</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FIXing less]]></title>
    <link href="http://btorpey.github.io/blog/2014/02/10/fixing-less/"/>
    <updated>2014-02-10T08:37:11-05:00</updated>
    <id>http://btorpey.github.io/blog/2014/02/10/fixing-less</id>
    <content type="html"><![CDATA[<p>Here's a handy tip for those who (like me) spend a fair amount of time staring
at FIX logs.

<!--more-->

FIX may be the protocol that everybody loves to hate, but it doesn't look like it's
going anywhere, so I guess we all just need to get over it and learn to live with it.

One of the things that is hard to live with, though -- at least for me -- is the
visual cacophony that results when browsing FIX logs with less.
<img class="center" src="/images/less-before.png"> 

It turns out that it's possible to control how less displays the x'01'
delimiters to make this chore a little easier on the eyes.  In my case, I
use the following in my .bash_profile:

`export LESSBINFMT="*u%x"`

This dials down the visual clutter to a level that I find much easier to deal
with.
<img class="center" src="/images/less-after.png"> 


(Note that the man page for less mentions that it's possible to display the hex codes in square brackets, but I have not found that to work on any of the systems where I've tried it -- YMMV).
</p>
]]></content>
  </entry>
  
</feed>
