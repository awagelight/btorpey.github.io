<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tidbits | Confessions of a Wall Street Programmer]]></title>
  <link href="http://btorpey.github.io/blog/categories/tidbits/atom.xml" rel="self"/>
  <link href="http://btorpey.github.io/"/>
  <updated>2015-10-19T18:45:14-04:00</updated>
  <id>http://btorpey.github.io/</id>
  <author>
    <name><![CDATA[Bill Torpey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remote Scripting with bash and ssh]]></title>
    <link href="http://btorpey.github.io/blog/2015/10/13/remote-scripting-with-bash-and-ssh/"/>
    <updated>2015-10-13T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2015/10/13/remote-scripting-with-bash-and-ssh</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/multimonitors.jpg" width="370" height="245">

Nowadays it's pretty common for applications to be distributed across multiple
machines, which can be good for scalability and resilience.

But it does mean that we have more machines to monitor -- sometimes a LOT more!

Read on for a handy tip that will let you do a lot of those tasks from any old
session (and maybe lose some of those screens)!

<!-- more -->

For really simple tasks, remote shell access using ssh is fine.  But oftentimes
the tasks we need to perform on these systems are complicated enough that they
really should be scripted.

And especially when under pressure, (e.g.,  troubleshooting a problem in a
production system) it's good for these tasks to be automated. For one thing,
that means they can be tested ahead of time, so you don't end up doing the
dreaded `rm -rf *` by mistake.  (Don't laugh -- I've actually seen that happen).

Now, I've seen people do this by copying scripts to a known location on the
remote machines so they can be executed.  That works, but has some
disadvantages: it clutters up the remote system(s), and it creates one more
artifact that needs to be distributed and managed (e.g., updated when it
changes).

If you've got a bunch of related scripts, then you're going to have to bite the
bullet and manage them (perhaps with something like Puppet).

But for simple tasks, the following trick can come in very handy:

`
ssh HOST ‘bash –s ‘ < local_script.sh
`

What we're doing here is running bash remotely and telling bash to get its input
from stdin.  We're also redirecting local_script.sh to the stdin of ssh, which
is what the remote bash will end up reading.

As long as local_script.sh is completely self-contained, this works like a
charm.

For instance, to login to a remote machine and see if hyper-threading is enabled
on that machine:

`
ssh HOST 'bash -s' < ht.sh
`

Where ht.sh looks like this:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (ht.sh)</span> <a href='/downloads/code/bash/ht.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nv">CPUFILE</span><span class="o">=</span>/proc/cpuinfo
</span><span class='line'><span class="nb">test</span> -f <span class="nv">$CPUFILE</span> <span class="o">||</span> <span class="nb">exit </span>1
</span><span class='line'><span class="nv">NUMPHY</span><span class="o">=</span><span class="sb">`</span>grep <span class="s2">&quot;physical id&quot;</span> <span class="nv">$CPUFILE</span> | sort -u | wc -l<span class="sb">`</span>
</span><span class='line'><span class="nv">NUMLOG</span><span class="o">=</span><span class="sb">`</span>grep <span class="s2">&quot;processor&quot;</span> <span class="nv">$CPUFILE</span> | wc -l<span class="sb">`</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="nv">$NUMPHY</span> -eq 1 <span class="o">]</span>
</span><span class='line'>  <span class="k">then</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo </span>This system has one physical CPU,
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo </span>This system has <span class="nv">$NUMPHY</span> physical CPUs,
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="nv">$NUMLOG</span> -gt 1 <span class="o">]</span>
</span><span class='line'>  <span class="k">then</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo </span>and <span class="nv">$NUMLOG</span> logical CPUs.
</span><span class='line'>    <span class="nv">NUMCORE</span><span class="o">=</span><span class="sb">`</span>grep <span class="s2">&quot;core id&quot;</span> <span class="nv">$CPUFILE</span> | sort -u | wc -l<span class="sb">`</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">[</span> <span class="nv">$NUMCORE</span> -gt 1 <span class="o">]</span>
</span><span class='line'>      <span class="k">then</span>
</span><span class='line'><span class="k">        </span><span class="nb">echo </span>For every physical CPU there are <span class="nv">$NUMCORE</span> cores.
</span><span class='line'>    <span class="k">fi</span>
</span><span class='line'><span class="k">  else</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo </span>and one logical CPU.
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="nb">echo</span> -n The CPU is a <span class="sb">`</span>grep <span class="s2">&quot;model name&quot;</span> <span class="nv">$CPUFILE</span> | sort -u | cut -d : -f 2-<span class="sb">`</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot; with`grep &quot;</span>cache size<span class="s2">&quot; $CPUFILE | sort -u | cut -d : -f 2-` cache&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>


(The script above was cribbed from http://unix.stackexchange.com/a/33509 --
thanks, Nils!)


Of course, all the normal redirection rules apply -- you just have to keep in
mind that you're redirecting to ssh, which is then redirecting to bash on the
input side.  On the output side, it's reversed.

Give this a try the next time you need to do some quick tasks over ssh and
you'll be able to get rid of a few of those monitors!
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repent, Sinner!]]></title>
    <link href="http://btorpey.github.io/blog/2014/09/21/repent/"/>
    <updated>2014-09-21T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/09/21/repent</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/nun-with-ruler.jpg" width="240" height="160"> 

When I was a kid I went to Catholic school, and back in those days 
the nuns would indeed rap your knuckles with a ruler if you
misbehaved. That doesn't happen so much any more, but when I see someone 
making use of the [copy-paste anti-pattern](http://c2.com/cgi/wiki?CopyAndPasteProgramming), 
I'm tempted to reach for a ruler myself. 
(I know, probably not a good career move ;-)

Short of rapping someone's knuckles with a ruler, though, how do you show some poor sinner the error of his ways?

<!--more-->

Enter [CPD, or copy-paste detector](http://pmd.sourceforge.net/pmd-5.1.3/cpd-usage.html). 
This does pretty much what you would guess from its name -- it
spins through all the code you give it, and analyzes it for repeated sequences.
[^1]

Here's an example of running the GUI version against the code I used 
in an [earlier post](http://btorpey.github.io/blog/2014/02/12/shared-singletons/) on smart pointers.

<img class="right" src="/images/cpd.png">

(Note that the "Ignore literals" and "Ignore identifiers" checkboxes are
disabled if you select C++ as the language - these options [are only implemented for Java currently](http://sourceforge.net/p/pmd/discussion/188193/thread/91553283)).

The site has several more examples, but [this one](http://pmd.sourceforge.net/pmd-5.1.3/cpdresults.txt) just blew my mind -- 
hard to imagine how anyone could write this code in
the first place, much less be so confident that it is correct that they just
copy and paste it in two different files (with nary a comment to tie the two
together)?

<pre>
=====================================================================
Found a 19 line (329 tokens) duplication in the following files: 
Starting at line 685 of /usr/local/java/src/java/util/BitSet.java
Starting at line 2270 of /usr/local/java/src/java/math/BigInteger.java
    static int bitLen(int w) {
        // Binary search - decision tree (5 tests, rarely 6)
        return
         (w < 1<<15 ?
          (w < 1<<7 ?
           (w < 1<<3 ?
            (w < 1<<1 ? (w < 1<<0 ? (w<0 ? 32 : 0) : 1) : (w < 1<<2 ? 2 : 3)) :
            (w < 1<<5 ? (w < 1<<4 ? 4 : 5) : (w < 1<<6 ? 6 : 7))) :
           (w < 1<<11 ?
            (w < 1<<9 ? (w < 1<<8 ? 8 : 9) : (w < 1<<10 ? 10 : 11)) :
            (w < 1<<13 ? (w < 1<<12 ? 12 : 13) : (w < 1<<14 ? 14 : 15)))) :
          (w < 1<<23 ?
           (w < 1<<19 ?
            (w < 1<<17 ? (w < 1<<16 ? 16 : 17) : (w < 1<<18 ? 18 : 19)) :
            (w < 1<<21 ? (w < 1<<20 ? 20 : 21) : (w < 1<<22 ? 22 : 23))) :
           (w < 1<<27 ?
            (w < 1<<25 ? (w < 1<<24 ? 24 : 25) : (w < 1<<26 ? 26 : 27)) :
            (w < 1<<29 ? (w < 1<<28 ? 28 : 29) : (w < 1<<30 ? 30 : 31)))));
    }

</pre>

So, if you need to lead someone to the light, try PMD's copy-paste detector.  It
may hurt a bit, but a lot less than a sharp rap on the knuckles!

One last caveat about CPD: it does not like symlinks at all -- you must give it the real path names for any source files, or
you will just get a bunch of "Skipping ... since it appears to be a symlink" messages.


[^1]: CPD is part of the [PMD tool](http://pmd.sourceforge.net/pmd-5.1.3/), which can do a lot of useful things with Java code. But since I'm primarily dealing with C++ code these days (and because duplicate code is such a hot-button issue for me), CPD is the part that I use.
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guess What Day It Is!]]></title>
    <link href="http://btorpey.github.io/blog/2014/07/23/perl-stdin/"/>
    <updated>2014-07-23T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/07/23/perl-stdin</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/phl.pm.org-camel.png" width="320" height="240"> 

No, not that -- it's Perl day.  (Well, actually it's just Wednesday, but you get the idea).

Sometimes it seems that everybody likes to hate on Perl, but I think their
animus is misdirected. It's not Perl that's the problem, it's those \^\\\$\(\.\#\!\)?$
regular expressions.

Or, as Jamie Zawinski once said 
["Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems."](http://en.wikiquote.org/wiki/Jamie_Zawinski).

Well, I'm here to tell you that it's possible to write whole Perl programs that
actually accomplish useful work,* without any regular expressions at all!* And, if you do
that, you can actually *read the code!*

It turns out that Perl is a dandy scripting language, and while some may take issue
with its flexibility ("There's more than one way to do it"), others (including me) find that flexibility very useful.

<!--more-->

One example of that flexibility is how easy it is to create a Perl program that
can read input either from stdin, or from a file specified on the command line.

    local *INFILE;
    if (defined($ARGV[0])) {
        open(INFILE, "<:crlf", "$ARGV[0]") or die "Cant open $ARGV[0]\n";
    }
    else {
        *INFILE = *STDIN;
    }

    while (<INFILE>) {
    }

    close(INFILE);

The above snippet does just that, and also works well with command-line parsers
(e.g., `GetOpt`) that eat their parameters by removing them from the ARGV
array.


</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where Am I?]]></title>
    <link href="http://btorpey.github.io/blog/2014/05/29/where-am-i/"/>
    <updated>2014-05-29T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/05/29/where-am-i</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/gilligans-island-tv-show.jpg" width="320" height="240"> 

From *Robinson Crusoe* to *Gilligan's Island* to *Lost*, tales of being
stranded on a desert island seem to resonate with people in a special way. Some
of that likely has to do with the exotic locales, and the practical challenges
of getting water, food and shelter.

But an even more basic part is the unanswered question: "Where am I?" that makes
things so -- well, *mysterious*.

Shell scripting can be pretty mysterious too at times, but in this installment
we'll learn how to answer that basic question of "Where am I?" to make shell
scripting a little less mysterious.

<!--more-->

One of the tenets of the Unix way is brevity, and one consequence of that is
that well-behaved programs should be able to find whatever other resources they
need without having to be told where they are. Windows attempts to
solve this problem with the (gack!) registry, but Unix tends to use a simpler
approach: needed resources are placed either in well-known locations (e.g., /etc
for system programs), or where they can be found relative to the location of the
program itself.

Another attribute of a well-behaved Unix program is that it
should be able to run from any location, whether it's invoked with a full path,
or found via the PATH variable.

So, how do we reconcile those two requirements? And specifically, how do we do
that in shell scripts? Since -- regardless of what your "main" language is, if
you're programming in Unix/Linux, you're probably also writing a boatload of
shell scripts too.

It turns out that, at least in bash, there is a
simple but non-obvious way to do get the location of the script file itself,
which goes something like this:

    SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE}) && /bin/pwd) 

Let's follow this through and see how it works:

-   The `$( ... )` construct invokes a sub-shell. This is handy since it
allows us to change the environment of the sub-shell (e.g., current directory)
without affecting the current environment.

-   `$BASH_SOURCE` is a builtin variable that gives us the path to the shell
script itself. For instance, if we invoke a script with `./scriptname.sh`,
then that's what will end up in `${BASH_SOURCE}`.

-   To get the full path then we extract just the path part with `dirname`, again
in a sub-shell.

-   We then `cd` into that directory, and if successful get the full pathname
with `/bin/pwd`.
    -   Note that we use `/bin/pwd` to get the path. This version resolves any
    symbolic links to return the actual physical path. There is also a `pwd`
    built-in to bash, but that one does not expand symbolic links by default.
<br>
-   Finally, the result is assigned to SCRIPT_DIR.

We now have the full path of the script file itself, and can use that to locate
any other resources needed by the script. For a real-world example, you can
check out the [these scripts](<https://github.com/btorpey/latency-utils.git>) from
 [my earlier post on visualizing latency](</blog/2014/05/16/visualizing-latency/>).


</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualizing Latency]]></title>
    <link href="http://btorpey.github.io/blog/2014/05/16/visualizing-latency/"/>
    <updated>2014-05-16T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/05/16/visualizing-latency</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/ping.png" width="320" height="240"> 

I'm a visual thinker (I think I may have [mentioned that before](http://btorpey.github.io/blog/2014/04/29/a-picture-is-worth-1k-words/) ),
so when I'm analyzing performance, latency, etc. I find it really helpful to be
able to visualize what is going on on the machine. 

As a result, I had gotten
reasonably good at using Excel to produce charts, which sometimes helped to correlate observed
behaviors like latency spikes with other events on the machine.

For a bunch of reasons I wanted to move away from Excel, though, and find
another tool that would give me the same or better functionality.

<!--more-->

For one thing, a little over a year ago I switched to a Mac as my main machine
after years of using Windows. There was a certain amount of adjustment, but for
the most part it's been smooth sailing. More than that, I was actually able to
recapture some of the fun and excitement I remember from my first Apple (an
Apple ][).

I also wanted something that would run on both the Mac and Linux, where I do
most of my testing. Last but not least, I wanted something that would be
scriptable so I could easily produce consistent charts for multiple test runs.

I looked briefly at R, but ditched it when it used up all the 8GB in my laptop,
plus the entire hard disk as swap, for a single dataset of 100,000 points.
Probably my bad, but I didn't have the patience to figure out what I might be
doing wrong.

At that point I turned to venerable (some would say crusty) gnuplot. It's a bit
long in the tooth, but I just wanted to plot latency over time, so how hard
could that be? Well, I guess it's pretty easy if you already know how, but
starting from scratch is another story.

Which brings me to my rant of the day, directed at techies in general, and to the
(us?) Linux/Unix techies in particular.

Short version: I don't want to learn gnuplot. I don't even want to *have
learned* gnuplot -- even if I could do that by just taking a pill. What I want
is to be able to produce decent-looking charts *without* knowing *anything*
about gnuplot.

To be fair, the gnuplot docs did have some examples -- more anyway than you
would find in a typical man page, although that's admittedly a low bar. And
while my google-fu is usually pretty good, I just couldn't find anything on the
intertubes that would work for me, so I had to learn *just a little* gnuplot.

> When all else fails, read the instructions.

It turns out that gnuplot works pretty well, and will probably work even better
once I learn (sigh) how to use it better.

But you don't have to learn diddly if you don't want to. [Here is the first](<https://github.com/btorpey/latency-utils.git>) in
what will hopefully be a series of recipes that you can use with little or no
modification.  Once you've downloaded the repo, enter the following at the command prompt:

`./tsd.sh ping.csv x11`

Which should result in something like this:

<img class="center" src="/images/gnuplot.png"> 

It's primitive, but that very primitiveness has its own appeal, especially for
those of us for whom "UI" means bash, vi or emacs.

A couple of points about the gnuplot command files:

-   Sometimes you care about the actual time that an event took place, so you
can correlate it with some other event; sometimes you don't. Accordingly, I've
created two different files: one which displays actual time (ts.gp), the other
which calculates and displays deltaT (tsd.gp).

-   I've been programming in C (and later C++) for many years, but I don't think
I've ever purposely used the comma operator before. Well, expressions in gnuplot
follow C language rules for operators, precedence, etc. and that comma operator
turns out to be handy -- in this case it lets us 
update the origin in the same expression that calculates deltaT.
(The return value of the comma
operator is the right-hand expression).

-- (Note that the above requires something like gnuplot 4.6)


-   I've left the default terminal in the gnuplot command files, but you can 
specify a different one on the command line.  To get a list of terminals supported 
in your version:
`gnuplot -e "set terminal"`.

Comments, suggestions, pull requests, etc. welcome.</p>
]]></content>
  </entry>
  
</feed>
