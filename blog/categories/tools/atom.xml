<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools | Confessions of a Wall Street Programmer]]></title>
  <link href="http://btorpey.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://btorpey.github.io/"/>
  <updated>2016-12-17T16:32:01-05:00</updated>
  <id>http://btorpey.github.io/</id>
  <author>
    <name><![CDATA[Bill Torpey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom-Tailored Configuration]]></title>
    <link href="http://btorpey.github.io/blog/2016/10/13/custom-tailor/"/>
    <updated>2016-10-13T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2016/10/13/custom-tailor</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/customtailor.jpg">

As developers, we seem to take a special delight in personalizing the virtual worlds in which we work -- from color palettes to keyboards, fonts, macros, you name it.  "Off-the-rack" is never good enough, we want Saville Row tailoring for our environments.

And a lot of the tools we use support and encourage that customization, giving us control over every little option.

But not every tool we use does so -- read on to learn a very simple trick to how to take control even when your tool doesn't make that easy.

<!-- more -->

In Linux, we have a couple of common ways to customize the way our tools work -- by defining environment variables, and by using configuration files.  Sometimes these two mechanisms work well together, and we can include environment variables in configuration files to make them flexible in different situations.

Not every tool can expand environment varaiables in its configuration files, however.  In that case, you can use this simple Perl one-liner to subsitute values from the environment into any plain-text file.

    perl -pe '$_=qx"/bin/echo -n \"$_\"";' < sample.ini


What's happpening here is

The `-p` switch tells Perl to read every line of input and print it.

The `-e` switch tells Perl to execute the supplied Perl code against every line of input.

The code snippet replaces the value of the input line (`$_`) with the results of the shell command specified by the `qx` function.  That shell command simply echos[^echo] the value of the line (`$_`), but it does so inside double quotes (the `\"`), which causes the shell to replace any environment variable with its value.

[^echo]: Note that we use /bin/echo here, instead of just plain echo, to get around an issue with the echo command in BSD (i.e., OSX).

And that's it!  Since the subsitution is being done by the shell itself, you can use either form for the environment variable (either `$VARIABLE` or `${VARIABLE}`), and the replacement is always done using the rules for the current shell.

Here's an example -- let's create a simple .ini type file, like so:

    username=$USER
    host=$HOSTNAME
    home-directory=$HOME
    current-directory=$PWD

When we run this file through our Perl one-liner, we get:

    perl -pe '$_=qx"/bin/echo -n \"$_\"";' < sample.ini
    username=btorpey
    host=btmac
    home-directory=/Users/btorpey
    current-directory=/Users/btorpey/blog/code/tailor

One thing to watch out for is that things can get a little hinky if your input file contains quotes, since the shell will interpret those, and probably not in the way you intend.  At least in my experience, that would be pretty rare -- but if you do get peculiar output that would be something to check.
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mo' Static]]></title>
    <link href="http://btorpey.github.io/blog/2016/04/07/mo-static/"/>
    <updated>2016-04-07T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2016/04/07/mo-static</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/nye-static.jpg" width="240" height="180">

- Will be replaced with the ToC, excluding the "Contents" header
{:toc}

In my day job, one of my main focuses is software reliability and correctness, so it makes sense that I would be a big fan of static analysis.

I've written previously about the [static analysis provided by clang](/blog/2015/04/27/static-analysis-with-clang/).  Today, I want to take a bit of a "deep-dive" into the whole subject by putting both clang and [cppcheck](http://cppcheck.sourceforge.net/) through their paces, using them to analyze a benchmark suite designed to exercise static analysis tools.  In the course of doing that, I'll also provide some helper scripts that make working with the tools easier.  

<!-- more -->

## Testing Static Analysis Tools

>  And what is good Phaedrus, and what is not good -- need we ask anyone to tell us these things? [^zen]  

[^zen]: Robert Pirsig, "Zen and the Art of Motorcycle Maintenance"

Obviously, the ultimate goal is to be able to run static analysis tools against our own codebase(s) to help detect and fix problems.  But how do we know if a particular tool is actually finding problems?  And, how do we know if we're running the tool properly?  

The perfect static analyzer would find all the latent bugs in our code, while not reporting any false positives[^fpos].  Since there are no perfect analyzers, any tool we use is going to miss some errors, and/or wrongly flag correct code.  So, the only way to evaluate an analyzer is to know where all the bugs are in our code -- but if we knew that, we wouldn't need an analyzer.

[^fpos]: A "false positive" is when a tool reports an error that is actually not.

That's a dilemma. To resolve it, we're going to be using a codebase specifically designed to trigger static analysis warnings.  The code was originally developed by Toyota ITC, and is available on [John Regehr's excellent blog](http://blog.regehr.org/archives/1217).  

The ITC benchmarks attempt to resolve our dilemma by providing both a set of code that contains errors which *should* trigger warnings, as well as a second set of code, similar to the first, but which doesn't contain errors.  Each source file is annotated with comments documenting where the errors are (and aren't).  And that lets us create a catalog of both real errors and potential false positives[^disclaimer]. 

To get started, download the code from [its GitHub repository](https://github.com/regehr/itc-benchmarks), and set the `ITCBENCH_ROOT` environment variable (which will come in handy later):

    $ git clone https://github.com/regehr/itc-benchmarks
    $ export ITCBENCH_ROOT=$(pwd)/itc-benchmarks

## Can I haz teh codez?
The remainder of this article goes step-by-step through the process of creating a compilation database from the ITC benchmark code, running clang's static analysis tools against that compilation database, building and installing cppcheck and running it against the compilation database, and analyzing the results.

This is all good stuff, especially if you're going to be using these tools going forward.  But, there's a certain amount of unavoidable yak-shaving[^yak] going on to get to that point.  So if you prefer to skip all that, I've included the results of running the different tools in the samples directory of the [repo](https://github.com/btorpey/static).  The samples include all the files we're going to be generating the hard way, so you can follow along without all the requisite busy-work.  Hopefully, when we're done you'll want to go back and use these tools on your own codebase. 

[^yak]: See <https://en.wiktionary.org/wiki/yak_shaving> for a description of this colorful term.

## Creating a compilation database
To run both clang and cppcheck we first need to create a "compilation database" to supply them with required build settings.  The [compilation database](http://clang.llvm.org/docs/JSONCompilationDatabase.html) format was developed as part of the clang project, to provide a way for different tools to query the actual options used to build each file.

A [good overview of how the compilation database works](http://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools) with clang-based tools can be found at Eli Bendersky's excellent site.  His article illustrates the importance of making sure that code analysis tools are looking at the same (pre-processed) source that the actual compiler sees, in order to generate meaningful diagnostics with a minimum of false positives.

- If you are using [cmake](http://cmake.org/) to drive your builds, creating a compilation database couldn't be easier -- simply add the `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON` parameter to the cmake build command, or add the following to your main CMakeLists.txt file:

    `set(CMAKE_EXPORT_COMPILE_COMMANDS ON)`

- If you're not using cmake, you can still create a compilation database using plain old make by front-ending make with [Bear](<https://github.com/rizsotto/Bear>)[^bear], like so:

    `bear make`

In either case, the end result should be the creation of a  `compile_commands.json` file in the current directory.

Sadly, the ITC benchmark suite is stuck in the past using [autotools](https://twitter.com/timmartin2/status/23365017839599616), and worse yet, a version that needs to be installed from source (on RH6, at least).     

So, in the interest of immediate gratification, I've included the compile\_commands.json file [here](/downloads/code/static/samples/compile_commands.json) -- simply save it to the directory where you've cloned the ITC code.  (The compile_commands.json file is also contained in the samples directory of the [repo for this article](https://github.com/btorpey/static)).

If you prefer to generate the compile_commands.json file yourself using Bear, you can do so like this:

    $ cd ${ITCBENCH_ROOT}  
    $ ./bootstrap
    $ ./configure
    $ bear make

[^bear]: Building and installing Bear from source is relatively straightforward -- just keep in mind that you need python >= 2.7.

## Establishing a baseline
To make it possible to compare results from different analyzers, we first need to establish a baseline using the ITC benchmarks, and for that we're going to need [this set of helper scripts](/pages/REAME.md/index.html), which can be downloaded from [this GitHub repo](https://github.com/btorpey/static).

    $ git clone https://github.com/btorpey/static
    
Once you've done that, you need to add the directory to your PATH:

    $ export PATH=$(pwd)/static/scripts:$PATH 

Enter the following command from the ITC source directory to create a csv file with the error annotations from the ITC code:

    $ cd ${ITCBENCH_ROOT}  
    $ cc_driver.pl -n grep -Hni ERROR: | 
    itc2csv.pl -r ${ITCBENCH_ROOT}/ | 
    sort -u > itc.csv  


The command will create a file named `itc.csv` in the source directory that looks like this:

    $ cat itc.csv
    "01.w_Defects/bit_shift.c:106","/*ERROR:Bit shift error*/"
    "01.w_Defects/bit_shift.c:120","/*ERROR:Bit shift error*/"
    "01.w_Defects/bit_shift.c:133","/*ERROR:Bit shift error*/"
    "01.w_Defects/bit_shift.c:146","/*ERROR:Bit shift error*/"
    "01.w_Defects/bit_shift.c:163","/*ERROR:Bit shift error*/"
    "01.w_Defects/bit_shift.c:175","/*ERROR:Bit shift error*/"
    ...

The format of the csv file is really simple -- just an entry for file and line number, and another with the error annotation munged from the source file.  This will give us a baseline against which to compare both clang and cppcheck.


## Using clang's analysis tools

In a couple of previous posts, I wrote about [static analysis with clang](/blog/2015/04/27/static-analysis-with-clang), and [how to build clang](/blog/2015/01/02/building-clang).  This next bit assumes that you've got clang ready-to-go, but if that's not the case, there can be a fair amount of work required to get to that point, so you may want to skip ahead to the section on [using cppcheck](#using-cppcheck).

We're going to use a similar approach to the one we used above to generate the list of expected errors from the ITC code.  The command below will run clang-check against all the files in compile_commands.json, filter the results, and reformat the output in csv format:

    $ cd ${ITCBENCH_ROOT}  
    $ cc_driver.pl clang-check -analyze 2>&1 | 
    clang2csv.pl -r ${ITCBENCH_ROOT}/ |
    sort -u > clangcheck.csv

This gives us the diagnostic messages produced by clang, in the same csv format as we used for the list of errors, above: 

    $ cat clangcheck.csv
    "01.w_Defects/bit_shift.c:106","warning: The result of the '<<' expression is undefined"
    "01.w_Defects/bit_shift.c:133","warning: The result of the '<<' expression is undefined"
    "01.w_Defects/bit_shift.c:146","warning: The result of the '<<' expression is undefined"
    "01.w_Defects/bit_shift.c:163","warning: The result of the '<<' expression is undefined"
    "01.w_Defects/bit_shift.c:175","warning: The result of the '<<' expression is undefined"
    ...

We can already see that there are some differences: the ITC code expects to see a diagnostic at 01.w_Defects/bit_shift.c:120, but clang doesn't output a warning for that line.

### Analyzing the results

What I like to do at this point is fire up my all-time favorite tool, [Beyond Compare](/blog/2013/01/29/beyond-compare/), to generate a visual diff of the two files:

<img class="center" src="/images/itcvsclang.png"> 

This view shows the expected diagnostics extracted from the ITC source files on the left, alongside the diagnostics generated by clang on the right.  We can see that clang catches some of the bugs in the source file, but misses others.  If we continue to read down the two files, we'll also see some potential "false positives" -- i.e., diagnostics issued by clang that are not marked as expected errors in the source files. 

The visual approach using Beyond Compare works well for me, but with a csv-formatted datafile, other approaches are possible as well.  We could import the diagnostic messages into a spreadsheet program, or even a DBMS, for archiving, tracking and comparison. 

## Running clang analysis (again)
clang actually has two tools for doing static analysis -- in the example above we ran `clang-check -analyze`, but now we're going to use `clang-tidy` instead.

    $ cd ${ITCBENCH_ROOT}  
    $ cc_driver.pl clang-tidy 2>&1 | 
    clang2csv.pl -r ${ITCBENCH_ROOT}/ | 
    sort -u > clangtidy.csv

If you compare the results from clang-check and clang-tidy, you'll notice that clang-tidy generally reports more warnings than clang-check.  Some of them are not necessarily defects, but are arguably bad practice (e.g., using `strcpy`).

<img class="center" src="/images/clangcheckvstidy.png"> 

clang-tidy also outputs a slightly different format, including the name of the check in brackets.  (The name can also be used to suppress the warning).

The choice of which to use is up to you -- my preference is to use clang-check first, and follow up with clang-tidy, simply because the warnings produced by clang-tidy either duplicate those from clang-check, or are not as serious.

Note that you can get a list of available checks from clang with the following command:

    $ clang -cc1 -analyzer-checker-help
    ...
    core.DivideZero                 Check for division by zero
    core.DynamicTypePropagation     Generate dynamic type information
    core.NonNullParamChecker        Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute
    core.NullDereference            Check for dereferences of null pointers
    core.StackAddressEscape         Check that addresses to stack memory do not escape the function


## Using cppcheck

There's another static analysis tool that can provide results comparable to clang.  [cppcheck](http://cppcheck.sourceforge.net/) has been around for a while, and I had tried to get it working in the past, but had given up after bumping into a few problems.

I kept hearing good things about cppcheck in [articles and presentations by others](#references), though, so I finally decided it would be worth the trouble to get it working.

It turns out the problems were not that difficult to solve, given a combination of documentation and experimentation.  And the benefits were significant, so I'm quite happy to have added cppcheck to my tool box.

### Installing cppchceck
While cppcheck is available bundled with some distros, it's often an older version, so we're going to build and install it from source. As is more and more often the case, cppcheck has started using features of C++1x, so we're going to need a C++1x-capable compiler to build it.

If you're on an older distro (in my case, RH6) where the system compiler is not C++1x-capable, see my [earlier post](/blog/2015/01/02/building-clang/) about how to build clang (and/or gcc) to get a C++1x-capable compiler.  (Basically, it uses an older version of gcc to build a newer version, and the newer version to build clang).  

It took some trial-and-error to get the cppcheck build parameters right, but the [supplied build script](/pages/build_cppcheck.sh/index.html) should get the job done[^install].

    $ ./build_cppcheck.sh 2>&1 | tee build_cppcheck.out

[^install]: As usual, I prefer installing external packages in a non-standard location, so the build script is set up to do that.  See [this post](/blog/2015/01/02/building-clang/) for an explanation and rationale of this approach).

#### Verifying the installation
You'll need to add the cppcheck directory to your PATH (assuming the install location from the build script):

    $ export PATH=/build/share/cppcheck/1.73/bin:$PATH

If the build and install process worked, you should be able to invoke cppcheck from the command line, like so:

    $ cppcheck --version
    Cppcheck 1.73
 
If you see the message below instead, there's a problem with the RPATH setting:
   
    $ cppcheck --version
    cppcheck: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15' not found (required by cppcheck)

The problem is typically either that the RPATH setting in the build is incorrect, or that the directory referenced by the RPATH setting does not exist.

### Running cppcheck

Now we're ready to run cppcheck, using the same approach we used with clang: 

    $ cd ${ITCBENCH_ROOT}  
    $ cc_driver.pl cppcheck.sh  2>&1 | 
    cppcheck2csv.pl -r ${ITCBENCH_ROOT} | 
    sort -u > cppcheck.csv

Note that instead of invoking cppcheck directly, we're invoking it via the [cppcheck.sh](/pages/cppcheck.sh/index.html) helper script, which supplies needed parameters to cppcheck.  It also creates an include file with the compiler's pre-defined macros, so those definitions will be visible to cppcheck.  This turns out to be particularly important with cppcheck, especially if the code you're trying to analyze uses `#ifdef`'s to control what code actually gets compiled (or seen by cppcheck)[^nosys].

[^nosys]: Note that cppcheck does not particularly like it when you include system include directories using `-I`.  Accordingly, we don't pass the `-s` switch to  cc_driver.pl when running cppcheck.

One of the settings in the helper script enables what cppcheck calls "inconclusive" results.  These are exactly what the name implies -- cppcheck isn't positive that the code is wrong, but it is at least suspicious.  Including these inconclusive results should tend to increase the number of false positives in theory, but in practice I haven't found false positives to be a big problem with either cppcheck or clang.  

### Analyzing the results
One of the first things you notice with cppcheck is that it includes more checks than clang.  Some of the additional warnings are for constructs that are not exactly *wrong*, but are either non-optimal, or indicators of potential problems.  For instance, cppcheck will warn when a variable is defined in a broader scope than is actually required ("scope ... can be reduced").  

<img class="center" src="/images/itcvscppcheck.png"> 

You can get a list of all the checks cppcheck is performing like so:

    $ cppcheck --doc 
    ...
    ## Other ##
    Other checks
    - division with zero
    - scoped object destroyed immediately after construction
    - assignment in an assert statement
    - free() or delete of an invalid memory location
    - bitwise operation with negative right operand
    - provide wrong dimensioned array to pipe() system command (--std=posix)


You can also generate a list of error ID's with this command:

    $ cppcheck --errorlist
    <error id="stringLiteralWrite" severity="error" msg="Modifying string literal directly or indirectly is undefined behaviour."/>
    <error id="sprintfOverlappingData" severity="error" msg="Undefined behavior: Variable &apos;varname&apos; is used as parameter and destination in s[n]printf()."/>
    <error id="strPlusChar" severity="error" msg="Unusual pointer arithmetic. A value of type &apos;char&apos; is added to a string literal."/>
    <error id="incorrectStringCompare" severity="style" msg="String literal &quot;Hello World&quot; doesn&apos;t match length argument for substr()."/>
    <error id="literalWithCharPtrCompare" severity="style" msg="String literal compared with variable &apos;foo&apos;. Did you intend to use strcmp() instead?"/>
    <error id="charLiteralWithCharPtrCompare" severity="style" msg="Char literal compared with pointer &apos;foo&apos;. Did you intend to dereference it?"/>
    <error id="incorrectStringBooleanError" severity="style" msg="Conversion of string literal &quot;Hello World&quot; to bool always evaluates to true."/>
 

You can suppress any errors you don't care to see by passing its id in the `--suppress=` flag.

## Comparing clang and cppcheck
There's a school of thought that says you should use as many compilers as possible to build your code, because each one will find different problems.  That's still a good idea, and even more so with static analysis tools.  

There's a certain amount of overlap between clang and cppcheck, but there are also significant differences.  In my experience, if clang reports something as a problem, it almost certainly is one, but clang also misses a lot of problems that it could detect.

<img class="center" src="/images/clangvscppcheck.png"> 

cppcheck can generate more warnings, and some of them are more stylistic issues, but it does detect certain classes of problems, like dead code and arithmetic over/underflow, that clang doesn't.

As I mentioned earlier, I haven't found false positives to be a major problem with either clang or cppcheck.

So, each tool has its place, and I like to use both.

# Conclusions
Static analysis tools can add real value to the software development process by detecting errors, especially errors in code that is never or almost never executed.

Commercial tools can be expensive (although still cheap compared to the money they save), and open-source tools can sometimes be hard to use (or at least hard to learn how to use).

The provided [helper scripts](/pages/REAME.md/index.html) ([repo here](https://github.com/btorpey/static)) should make it much easier to use these tools, and to keep track of warnings and compare the outputs of different tools by using a common format.

They can also be useful for before-and-after comparisions of different versions of a single codebase -- for example, as changes are being made to address issues detected by the tools.

# Acknowledgements
In addition to the people, projects and organizations mentioned earlier, the people at the NIST have been very helpful, and maintain an incredible collection of resources on the topic of static analysis for a number of languages, not just C++.  Some of those resources include the following, and are well worth checking out:

<https://samate.nist.gov/index.php/SAMATE_Publications.html>  
<https://samate.nist.gov/SARD/>  

If you've read any of my other posts, you may have noticed that the contents sidebar at the beginning of the article is a new thing.  Especially for longer-format articles, that TOC would seem to be very helpful.  Many thanks to [Robert Riemann](http://blog.riemann.cc/2013/04/10/table-of-contents-in-octopress/) for taking the trouble to explain how to do it.

I've been using the very nice [MacDown](http://macdown.uranusjr.com/) editor to create these posts -- thanks, Tzu-Ping!

# References
Some helpful references that I ran across while researching this article:

[Static Code Analysis, John Carmack](http://www.viva64.com/en/a/0087/)

[CppCon 2015: Jason Turner “The Current State of (free) Static Analysis"](https://youtu.be/sn1Vg8A_MPU)

[CppCon 2015: Neil MacIntosh “Static Analysis and C++: More Than Lint"](https://youtu.be/rKlHvAw1z50)

---

[^disclaimer]: Full disclaimer: I have not taken the time to review all of the ITC source to verify that the annotations are accurate and/or complete.  For the purpose of this exercise, we'll agree to assume that they are -- but if you'd like to suggest any improvements, I'm guessing the best place to do that would on the [repo](https://github.com/regehr/itc-benchmarks).

</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remote Scripting with bash and ssh]]></title>
    <link href="http://btorpey.github.io/blog/2015/10/13/remote-scripting-with-bash-and-ssh/"/>
    <updated>2015-10-13T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2015/10/13/remote-scripting-with-bash-and-ssh</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/multimonitors.jpg" width="370" height="245">

Nowadays it's pretty common for applications to be distributed across multiple
machines, which can be good for scalability and resilience.

But it does mean that we have more machines to monitor -- sometimes a LOT more!

Read on for a handy tip that will let you do a lot of those tasks from any old
session (and maybe lose some of those screens)!

<!-- more -->

For really simple tasks, remote shell access using ssh is fine.  But oftentimes
the tasks we need to perform on these systems are complicated enough that they
really should be scripted.

And especially when under pressure, (e.g.,  troubleshooting a problem in a
production system) it's good for these tasks to be automated. For one thing,
that means they can be tested ahead of time, so you don't end up doing the
dreaded `rm -rf *` by mistake.  (Don't laugh -- I've actually seen that happen).

Now, I've seen people do this by copying scripts to a known location on the
remote machines so they can be executed.  That works, but has some
disadvantages: it clutters up the remote system(s), and it creates one more
artifact that needs to be distributed and managed (e.g., updated when it
changes).

If you've got a bunch of related scripts, then you're going to have to bite the
bullet and manage them (perhaps with something like Puppet).

But for simple tasks, the following trick can come in very handy:

`
ssh HOST ‘bash –s ‘ < local_script.sh
`

What we're doing here is running bash remotely and telling bash to get its input
from stdin.  We're also redirecting local_script.sh to the stdin of ssh, which
is what the remote bash will end up reading.

As long as local_script.sh is completely self-contained, this works like a
charm.

For instance, to login to a remote machine and see if hyper-threading is enabled
on that machine:

`
ssh HOST 'bash -s' < ht.sh
`

Where ht.sh looks like this:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (ht.sh)</span> <a href='/downloads/code/bash/ht.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="c"># cribbed from http://unix.stackexchange.com/questions/33450/checking-if-hyperthreading-is-enabled-or-not</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c"># NOTE:  There does not seem to be a good way to determine if HT is available but not enabled on a particular machine:</span>
</span><span class='line'><span class="c"># - &#39;ht&#39; flag in /proc/cpuinfo is unreliable</span>
</span><span class='line'><span class="c"># - lscpu could be used, but is not part of RH5</span>
</span><span class='line'><span class="c"># - dmidecode could be used, but requires root permissions</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c"># So for now we just report whether HT is enabled or not</span>
</span><span class='line'>
</span><span class='line'><span class="nb">echo</span> -n <span class="k">${</span><span class="nv">HOSTNAME</span><span class="k">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">nproc</span><span class="o">=</span><span class="k">$(</span>grep -i <span class="s2">&quot;processor&quot;</span> /proc/cpuinfo | sort -u | wc -l<span class="k">)</span>
</span><span class='line'><span class="nv">phycore</span><span class="o">=</span><span class="k">$(</span>cat /proc/cpuinfo | egrep <span class="s2">&quot;core id|physical id&quot;</span> | tr -d <span class="s2">&quot;\n&quot;</span> | sed s/physical/<span class="se">\\</span>nphysical/g | grep -v ^<span class="nv">$ </span>| sort -u | wc -l<span class="k">)</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;$(echo &quot;</span><span class="nv">$phycore</span> *2<span class="s2">&quot; | bc | grep $nproc)&quot;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">   </span><span class="nb">echo</span> <span class="s2">&quot;: HT disabled&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="k">   </span><span class="nb">echo</span> <span class="s2">&quot;: HT enabled&quot;</span>
</span><span class='line'><span class="k">fi</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>


(The script above was cribbed from http://unix.stackexchange.com/a/33509 --
thanks, Nils!)


Of course, all the normal redirection rules apply -- you just have to keep in
mind that you're redirecting to ssh, which is then redirecting to bash on the
input side.  On the output side, it's reversed.

Give this a try the next time you need to do some quick tasks over ssh and
you'll be able to get rid of a few of those monitors!
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Static Analysis with clang]]></title>
    <link href="http://btorpey.github.io/blog/2015/04/27/static-analysis-with-clang/"/>
    <updated>2015-04-27T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2015/04/27/static-analysis-with-clang</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/coil3.jpg" width="195" height="281">

I keep singing the praises of clang, and with good reason -- the [clang project](<http://clang.llvm.org/>) has been advancing the state of C/C++ compiler technology on Linux and OS X for quite a while now.  

The modular design of the compiler has also enabled the creation of a set of ancillary tools, including run-time "sanitizers" (which I [wrote about earlier](http://btorpey.github.io/blog/2014/03/27/using-clangs-address-sanitizer/)), as well as pretty-printers, and a tool to automatically upgrade code to C++11. 

Today I want to talk about clang's static analysis engine, which can do a deep-dive on your code and find problems that are hard for a human to detect, but that are amenable to a brute-force approach that models the run-time behavior of a piece of code, but at compile-time.

<!-- more -->

This is very different from dynamic analysis tools, like valgrind and clang's own sanitizers, which instrument the code at run-time to detect actual errors (e.g., reading uninitialized memory) that happen while the code is running.  With dynamic analysis, the only errors that can be detected are in code that is actually executed, so a latent bug that only manifests under unusual conditions[^heisenbug], can go un-detected.  By contrast, static analysis can potentially find bugs in code that is never (or almost never) actually executed.  

[^heisenbug]:  These are often called "Heisenbugs", in a nerd-humor pun on the [Heisenberg Uncertainty Principle](<http://en.wikipedia.org/wiki/Uncertainty_principle>).

Sounds good, no?  Who wouldn't want to find bugs "automagically", without even needing to do any testing.  (Cause we all know how much programmers love testing ;-)

For example, running clang's static analyzer on some sample code turns up warnings similar to the following:

- Value stored to 'x' is never read
- The right operand of '!=' is a garbage value
- Potential leak of memory pointed to by 'x'
- Function call argument is an uninitialized value
- Use of memory after it is freed
- Called C++ object pointer is null

Some of the above warnings (e.g., value stored is never read) are most likely harmless, and just sloppy coding (perhaps because of copy-paste syndrome, about which I have more to say [here](http://btorpey.github.io/blog/2014/09/21/repent/)).  Others (e.g., called pointer is null), might be false positives, given the algorithms the analyzer uses[^falsepos].  Or, they could be real bugs that you just haven't hit yet, because the code is (almost) never executed.

[^falsepos]:  For instance, clang's analayzer attempts to figure out if a pointer can possibly be NULL by seeing if there is any code that checks for that condition.  If there is, then clang complains about any code that dereferences the pointer outside an `if (x != NULL)` block.  This algorithm isn't perfect, but it's about the best that can be done, especially since the analyzer only looks at a single file at a time.

Those are the really scary bugs, along with the ones where you can "get lucky" most of the time ... except when you don't.  The "garbage value" and "unitialized value" warnings fall into that category, and can be very hard to eyeball.  Again, dynamic analysis tools like valgrind can help find these bugs, but only if you hit that code in testing.

So, static analysis *is* good, but it's not magic.  Static analyzers can only find bugs that they are programmed to find, and they certainly don't find all bugs.  For instance, here's a bug that clang's static analysis doesn't find:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">buf2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">strncpy</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf2</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

But the fact is that static analysis *will* find bugs, and it will find bugs that you most likely wouldn't find on your own, so it's a a good tool to have in your toolbox.  So, let's take a look at how to do that using clang.

The first step is to install clang.  If you're on OS X or Ubuntu, you should already have it, but if you're on RedHat this can be a bit tricky, so see [my previous post](http://btorpey.github.io/blog/2015/01/02/building-clang/) on how to get clang working.  (I've updated that post to add instructions for installing some of the static analysis tools that don't normally get installed with clang).

It turns out that there are three (3) different ways to run clang's static analyzer on your code, each with its own benefits and drawbacks.  We'll consider each of these in turn:

## Integrated with a typical build

If you use reasonably normal-looking makefiles to build your code, you can get static analysis going with a minimum of fuss.  If you're using cmake to create your makefiles, the same approach will work fine, so long as you're not overriding the values of CMAKE_C_COMPILER etc.  (And, as usual, if you're using autotools, [you're on your own;-)](https://twitter.com/timmartin2/status/23365017839599616).  

In this approach, you `export` some environment variables to invoke the analyzer instead of the compiler, like the following:

Variable|Value       |Meaning
--------|------------|-------
CC|ccc-analyzer|C compiler is redirected to clang analyzer (which in turn invokes the compiler, using the value of CCC_CC, below).
CXX|c++-analyzer|Similar to above, but for C++.
CCC_CC|clang|This environment variable is used by ccc-analyzer to invoke the actual C compiler.
CCC_CXX|clang++|ditto
LD|clang++|Specifies that the actual compiler should be used for linking.
CCC\_ANALYZER_VERBOSE|1|(Optional) Set this flag to get verbose output from the analyzer, including the list of errors checked.

<br>
With those variables set, you should just be able to invoke `make` to build your project, and Bob's your uncle.

One nice thing about this approach is that you get both compiler warnings and analyzer warnings together -- first, the analyzer invokes the compiler on the source file, and then performs the static analysis.

## Using the GUI tool

In a similar fashion as ccc-analyzer (above) front-ends make, you can use clang's [scan-build](http://clang-analyzer.llvm.org/scan-build.html) tool to front-end ccc-analyzer. In addition to invoking the compiler and analyzer, scan-build also collects the analyzer reports, including the control flow that the analyzer used to infer any errors, and presents that using a set of html pages that are written by default to the /tmp directory, and that look like this:

![](http://clang-analyzer.llvm.org/images/analyzer_html.png)

Personally, I find this fascinating.  Not only does the analyzer tell about what it thinks is a problem, but also *why* it thinks so.  

In the example above, you can see the steps that the analyzer follows to figure out that there is a problem with the code.  If you are wondering whether a particular warning is a false positive or not, this presentation can help you figure that out.  [^false2] It can also sometimes provide unexpected insights into the code that you might not come up with on your own.

To use this approach, you set your environment variables the same as described above, but instead of running make, you run `scan-build -V make`.  This will run your build and then launch a browser to view the results of the build.

### A small hitch...

Unfortunately, scan-build (and its scan-view companion) are not installed by default with clang.  I've updated the build script from my [earlier post](http://btorpey.github.io/blog/2015/01/02/building-clang/) on building clang on RedHat to install these files, but if you want to do it manually, run the following from the source tree you used to build and install clang:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># we need some addl bits that are not normally installed</span>
</span><span class='line'>cp -p  llvm/tools/clang/tools/scan-build/scan-build     <span class="k">$(</span>which clang<span class="k">)</span>/..
</span><span class='line'>cp -p  llvm/tools/clang/tools/scan-build/ccc-analyzer   <span class="k">$(</span>which clang<span class="k">)</span>/..
</span><span class='line'>cp -p  llvm/tools/clang/tools/scan-build/c++-analyzer   <span class="k">$(</span>which clang<span class="k">)</span>/..
</span><span class='line'>cp -p  llvm/tools/clang/tools/scan-build/sorttable.js   <span class="k">$(</span>which clang<span class="k">)</span>/..
</span><span class='line'>cp -p  llvm/tools/clang/tools/scan-build/scanview.css   <span class="k">$(</span>which clang<span class="k">)</span>/..
</span><span class='line'>cp -rp llvm/tools/clang/tools/scan-view/*               <span class="k">$(</span>which clang<span class="k">)</span>/..
</span></code></pre></td></tr></table></div></figure></notextile></div>
 
### Another small hitch...
In an [earlier post](http://btorpey.github.io/blog/2015/03/17/shadow/), I talked about how to use the `-isystem` flag to prevent selected headers from generating warnings.  Unfortunately, the [clang analyzer chokes on that flag](https://llvm.org/bugs/show_bug.cgi?id=13237#c9) -- so if you're using it, you will need to apply the patch below to successfully run the analyzer.  

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>svn diff ccc-analyzer
</span><span class='line'>Index: ccc-analyzer
</span><span class='line'><span class="o">===================================================================</span>
</span><span class='line'>--- ccc-analyzer	<span class="o">(</span>revision 234604<span class="o">)</span>
</span><span class='line'>+++ ccc-analyzer	<span class="o">(</span>working copy<span class="o">)</span>
</span><span class='line'>@@ -354,7 +354,8 @@
</span><span class='line'>   <span class="s1">&#39;-iprefix&#39;</span> <span class="o">=</span>&gt; 1,
</span><span class='line'>   <span class="s1">&#39;-iquote&#39;</span> <span class="o">=</span>&gt; 1,
</span><span class='line'>   <span class="s1">&#39;-iwithprefix&#39;</span> <span class="o">=</span>&gt; 1,
</span><span class='line'>-  <span class="s1">&#39;-iwithprefixbefore&#39;</span> <span class="o">=</span>&gt; 1
</span><span class='line'>+  <span class="s1">&#39;-iwithprefixbefore&#39;</span> <span class="o">=</span>&gt; 1,
</span><span class='line'>+  <span class="s1">&#39;-isystem&#39;</span> <span class="o">=</span>&gt; 1,
</span><span class='line'> <span class="o">)</span>;
</span><span class='line'>
</span><span class='line'> my %LinkerOptionMap <span class="o">=</span> <span class="o">(</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

[^false2]: At least in my experience, many of the warnings that appear at first to be false positives turn out to be real bugs, especially if you follow through the control flow the analyzer uses.

## Using a compilation database

Last but not least, you can also use a "compilation database" to invoke the static analyzer directly.  So, what is a compilation database, you ask?  This is a [simple format](http://clang.llvm.org/docs/JSONCompilationDatabase.html) introduced by clang that records the actual commands used to generate intermediate build products from source files, along with their parameters.

The analyzer needs this information to reproduce the environment used by the compiler, including pre-processor definitions and include file search paths.  

If you are using [cmake](http://cmake.org/) to drive your builds, creating a compilation database couldn't be easier -- simply add the `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON` parameter to the cmake build command, or add the following to your main CMakeLists.txt file:

`set(CMAKE_EXPORT_COMPILE_COMMANDS ON)`

If you're not using cmake, you can still create a compilation database using plain old make by front-ending make with [Bear](<https://github.com/rizsotto/Bear>)[^bear], like so:

`bear make`

This will use Bear to drive the make process, leaving a `compile_commands.json` file in the current directory.

[^bear]: Building and installing Bear from source is relatively straightforward -- just keep in mind that you need python >= 2.7.

Once you've got the compilation database, invoking the analyzer can be done with a command like the following:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">COMPILE_DB</span><span class="o">=</span><span class="k">$(</span>/bin/pwd<span class="k">)</span>;
</span><span class='line'>grep file compile_commands.json |
</span><span class='line'>awk <span class="s1">&#39;{ print $2; }&#39;</span> |
</span><span class='line'>sed <span class="s1">&#39;s/\&quot;//g&#39;</span> |
</span><span class='line'><span class="k">while </span><span class="nb">read </span>FILE; <span class="k">do</span>
</span><span class='line'>  <span class="o">(</span><span class="nb">cd</span> <span class="k">$(</span>dirname <span class="k">${</span><span class="nv">FILE</span><span class="k">})</span>;
</span><span class='line'>   clang-check -analyze -p <span class="k">${</span><span class="nv">COMPILE_DB</span><span class="k">}</span> <span class="k">$(</span>basename <span class="k">${</span><span class="nv">FILE</span><span class="k">})</span>
</span><span class='line'>  <span class="o">)</span>;
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

(There are simpler ways to invoke the analyzer, but the approach shown here will visit each source file in the same order that it was originally built, which can be handy).


## Conclusion
As we said earlier, static analysis is not magic, and it certainly won't find all your bugs.  But it will probably find some, and the ones it finds are likely to be nasty, so it's worth a certain amount of trouble.

Last but not least, this is by no means a complete explanation of clang's analyzer.  Like much of clang, the documentation lags the code, sometimes by a lot, so much of this information was obtained by trial-and-error, and/or by reading the code.  So, if you find something interesting, please [drop me a line](<mailto:wallstprog@gmail.com>), or leave a note in the comments section. 


## References

<http://clang.llvm.org/>

<http://clang-analyzer.llvm.org/index.html>

<http://clang.llvm.org/docs/ClangCheck.html>





</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Who Knows What Evil Lurks ...]]></title>
    <link href="http://btorpey.github.io/blog/2015/03/17/shadow/"/>
    <updated>2015-03-17T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2015/03/17/shadow</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/TheShadowComic01.jpg" width="222" height="333">

Pity the poor Shadow!  Even with the recent glut of super-heroes in movies, games and TV, the Shadow is nowhere to be seen.  

But I guess that's the whole point of being the Shadow.  

According to [this](http://en.wikipedia.org/wiki/The_Shadow), the Shadow had "the mysterious power to cloud men's minds, so they could not see him".  Hmmm, that sounds like more than a few bugs I've known.

Read on to learn how to get your compiler to help you find and eliminate these "shadow bugs" from your code.

<!-- more -->

Recently I was cleaning up the code for one of our test programs, and I
suddenly started getting a crash at shutdown that I hadn’t seen before. The
stack trace looked more or less like I expected (except for the SEGV, of
course), and I spent several minutes staring at the code before the light bulb
came on.

As is often the case, once the light bulb did come on, my first reaction was
“Duh!”. It was a dumb mistake, but then I started to think: if it’s such a dumb
mistake, why didn’t the compiler warn me about it? Answering that question got
me looking into the state of compiler diagnostics, and taught me a few things I
hadn’t known (or had forgotten).

First, let’s take a look at the bug that was a bit of a head-scratcher, and that
prompted this post. I’ve distilled it down to just a few lines of code — take a
look and see if you can spot the bug:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (shadow.cpp)</span> <a href='/downloads/code/shadow/shadow.cpp'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">D</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>   <span class="kt">void</span> <span class="n">Init</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>   <span class="n">C</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">D</span><span class="o">*</span> <span class="n">_pD</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">;</span>
</span><span class='line'>      <span class="n">_pD</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="o">~</span><span class="n">C</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">_pD</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>   <span class="n">D</span><span class="o">*</span> <span class="n">_pD</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

The bug is in C's constructor, where instead of initializing the member variable (_pD), the
code instead creates a local variable with the same name. The local variable goes
out of scope on return and gets deleted (although the allocation
persists), but the member variable of the same name remains uninitialized. The
problem comes when we delete c, since C’s dtor deletes a pointer that is just a
bunch of random bits[^4]. The fix, of course, is to omit the type declaration on the
assignment, which causes the compiler to assign to the member variable, rather
than creating and then assigning to a local (stack) variable.

(I can already hear the howls of outrage at this code -- see [^1], [^2] and [^3] for a discussion if you're so inclined).

Granted that there are ways to avoid this problem by writing the code "correctly" (perfectly?) in the
first place. But still, if it’s such a dumb mistake, why didn’t the
compiler warn about it?

That was what puzzled me, especially since I thought our “diagnostic hygiene”
was pretty good. All our code is built with “-Wall -Wextra”, which is not quite
“everything but the kitchen sink”, but close.

But when we build with those flags, the compiler is perfectly happy:
<pre>
$ clang++ -g -Wall -Wextra shadow.cpp
$
</pre>

But running -- that's another story:
<pre>
$ ./a.out
*** glibc detected *** ./a.out: free(): invalid pointer: 0x0000000000400600 ***
...
Aborted (core dumped)
$ 
</pre>

When we load the core file into the debugger, we see that the offending instruction is the delete of _pD in C's destructor:

<pre>
$ gdb a.out core.897
(gdb) bt
#0  0x0000003a86032925 in raise () from /lib64/libc.so.6
#1  0x0000003a86034105 in abort () from /lib64/libc.so.6
#2  0x0000003a86070837 in __libc_message () from /lib64/libc.so.6
#3  0x0000003a86076166 in malloc_printerr () from /lib64/libc.so.6
#4  0x0000000000400720 in C::~C (this=0x7fffe6dbdec8) at shadow.cpp:23
#5  0x00000000004006a9 in main () at shadow.cpp:37
(gdb) 
</pre>

The result above is just one of three possible results. Let's take a look at each of these in turn:

1.  You may get no message at all - the code (appears to) work fine. 

	This is the result we get if we use gcc to compile the code.  With gcc, the allocation is (presumably) being satisfied by the operating system (e.g., by calling [sbrk](http://pubs.opengroup.org/onlinepubs/007908775/xsh/brk.html)).  Typically, the OS will zero-fill any memory that it allocates as a security precaution (see [here](http://stackoverflow.com/questions/8029584/why-does-malloc-initialize-the-values-to-0-in-gcc)  and [here](http://stackoverflow.com/questions/2688466/why-mallocmemset-is-slower-than-calloc) for details).  

	So, in this case, we're deleting a nullptr, and that is perfectly kosher [according to the standard](http://en.cppreference.com/w/c/memory/free). (Why that is may be a cause for debate, but it is).[^non-null]

[^non-null]:	Another possibility is that the bits are non-NULL, but the call to free doesn't immediately crash.  Instead, it may leave the data structures used to manage the heap in an inconsistent state, in such a way that it will cause a crash later.  This is the worst possible scenario, since this problem is almost impossible to debug.  In an upcoming column we're going to look at this situation in more detail, and talk about ways to avoid it.
	

2. You may get a message similar to  `*** glibc detected *** ./a.out: free(): invalid pointer` followed by a stack trace.  
 
	This happens when glibc can detect that the pointer being freed was not previously allocated.

	The memory management functions in glibc contain runtime checks to catch error conditions.  Some of these checks are enabled in all cases (because they are relatively inexpensive), while others must be specifically enabled.[^malloc-check]  In this particular case, the code in `free` is checking to see if the address being passed in has previously been allocated using e.g. `malloc`.  If not, the code signals an error.

	This is the result we get when using clang -- with clang, the  allocation request is being satisfied from memory that was previously allocated and freed, so the bits that make up the member variable _pD have already been scribbled on (i.e., they are non-zero), but glibc can tell the address is not one that was previously allocated.

3. You may get a message similar to `Segmentation fault (core dumped)`.  
	
	In our case, C's destructor is pretty minimal -- it just deletes the \_pD member variable.  In other cases, though, C's destructor may attempt to do more complicated processing before returning, and in those cases it's quite possible that that processing will trigger a crash on its own.  (For instance, if _pD is defined as a shared_ptr as opposed to a raw pointer, you would likely see a segmentation violation in the code that manipulates the shared_ptr).

# ... the Shadow Knows
This all could have been avoided if the compiler recongized that the declaration of _pD in C's constructor
hid the member variable, and with "-Wshadow" enabled in the compile, that is exactly what happens:

<pre>
﻿$ clang++ -Wall -Wextra -Wshadow shadow.cpp
shadow.cpp:17:10: warning: declaration shadows a field of 'C' [-Wshadow]
      D* _pD = new D;
         ^
shadow.cpp:27:7: note: previous declaration is here
   D* _pD;   
      ^
1 warning generated.
$
</pre>

gcc supports the flag also, although the message is slightly different
<pre>
$ g++ -Wall -Wextra -Wshadow shadow.cpp
shadow.cpp: In constructor ‘C::C()’:
shadow.cpp:17: warning: declaration of ‘_pD’ shadows a member of 'this'
$
</pre>

While both gcc and clang support the "-Wshadow" flag, the implementations are very different.  
gcc appears to strive for completeness, and in the process produces so many warnings as to render the use 
of "-Wshadow" pretty much useless.  That was certainly Linus’ opinion when
he wrote [this](<https://lkml.org/lkml/2006/11/28/239>), and it’s hard to
disagree.

The good news is that the clang developers have come up with a much
more useful implementation of "-Wshadow", which avoids a lot of the problems
Linus talks about.  For example, on one legacy-ish code base, gcc reports over 1100 shadow
warnings vs. just three for clang.  There's a terrific explanation  [here](<http://programmers.stackexchange.com/questions/122608/clang-warning-flags-for-objective-c-development/124574#124574>)
about how the clang team decides what category a particular diagnostic should belong to.

## Third-party Libraries

But, what if we use third-party libraries in our programs?  While clang does a very good job
of filtering out "false positive" shadow warnings, they can still crop up in some libraries, including Boost.  One
possible solution is to have wrapper includes that use #pragma's to suppress (or enable) certain warnings, prior to including
the real library headers.  That is in fact the approach suggested by the Boost maintainer when someone posted 
[a bug report](<https://svn.boost.org/trac/boost/ticket/9378#comment:15>) about 
the shadow warnings in Boost.  

But, that's tedious, error-prone, inconvenient and expensive.  Is there a better way?

It turns out that there is -- both gcc and clang provide the `-isystem` compiler flag to include header files, subject to 
[special rules](<https://gcc.gnu.org/onlinedocs/cpp/System-Headers.html>) that effectively eliminate warnings, 
even in macros that are expanded at compile-time.  

Note that if you're using cmake, the way to enable `-isystem` is to use the SYSTEM flag to include_directories, like so: 
`include_directories(SYSTEM ${Boost_INCLUDE_DIRS})`

## Fixing the code
There are three types of shadow warnings, each with a different cause and potential to cause trouble.  The different types are distinguished by what follows after the "warning: declaration shadows a" message:

|Type  | Explanation |
|------------- | -------------------------------------------- | 
| local variable | These are typically the least likely to be real problems, since local variables have limited lifetimes by defintion.  Even if these warnings don't indicate a genuine problem, it is best to eliminate them  by changing one or the other variable name, if only to prevent future confusion.
| field of "X" | As in the example above, these shadow warnings often point to a potential problem, given how easy it is to inadvertently include a type prefix in the statement meant to initialize the member variable, thereby declaring (and initializing) a new local variable instead.
| variable in the global namespace | This is perhaps the most dangerous of the three types, since accidentally introducing a new variable into scope can easily go unnoticed.  Everything appears to be working correctly, until at some point the newly introduced variable goes out of scope, exposing the un-initialized global variable.  

<br>

# Conclusion

I originally thought this would be a quick post about a somewhat obscure compiler warning -- maybe a 
"tidbit", but certainly nothing more than that.  But, as Tolkien said about "Lord of the Rings", "the tale grew in the telling".

Let's see what we've covered:

- What "-Wshadow" means, and why you might want to use it.
- How to selectively disable warnings, including "-Wshadow", for third-party libraries when
it creates more noise than value.
- How even seemingly trivial code can behave very differently when compiled with different compilers (e.g., gcc vs. clang).
- How to use value initialization to initialize even POD types to known (zero) values.

And that doesn't even include one of my original goals, which was to talk about compiler warnings
in general, and which ones you want to make sure you use in all your builds.  That will have to wait
for next time.

## TL;DR
- Enable "-Wshadow" in addition to whatever other compiler warnings you're using.  
  * Fix the warnings, even if they don't (appear to) matter.
- But only if you're using [clang](http://clang.llvm.org/)!
  * And if you're not using clang yet, it's time to start.
  * If you need help getting clang up and running on your system, be sure to check out [my earlier post](<http://btorpey.github.io/blog/2015/01/02/building-clang/>).



[^1]: The first point is that we should be initializing the member variable in the ctor, rather than assigning it, which would make this mistake impossible. That’s a valid point, mostly, but there are times when you can make a case for assignment being a simpler approach — for example, when you have multiple member variables, and when the order of assignment matters. Remember that member variables are initialized in the order of their declaration, not the order in which the initializers appear. Given that the order of declaration is often not obvious, it’s easy to see why one might prefer to use assignment to enforce the order of assignment in the body of the constructor.

[^2]: Another mostly valid point is that, if we are going to assign in the body of the ctor, we should at least initialize the members to some value before entering the constructor. The only defense to that is a misguided attempt to optimize out the initialization code, since we know we’re assigning to the member variable anyway. That’s arguably wrong, but not terribly so, and in any event is pretty common, at least in my experience. (OK, smarty-pants, do YOU always initialize ALL your member variables in EVERY constructor you write? Even if you're going to assign to them in the body of the constructor?  Really? Do you want your merit badge now, or at the jamboree?)

[^3]: Last but not least, we could use [value initialization](http://stackoverflow.com/a/2418195/203044) to ensure that even POD types in the class are [zero-initialized](http://en.cppreference.com/w/cpp/language/zero_initialization).

[^malloc-check]: We'll be discusing how to use glibc's error-checking in a future column.

[^4]: At least [according to the standard](http://en.cppreference.com/w/cpp/language/default_initialization).  Different implementations can, and do, behave differently. Or, as the old saying goes: "In theory, there is no difference between theory and practice.  In practice, there is".</p>
]]></content>
  </entry>
  
</feed>
