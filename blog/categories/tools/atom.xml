<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools | Confessions of a Wall Street Programmer]]></title>
  <link href="http://btorpey.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://btorpey.github.io/"/>
  <updated>2015-01-05T10:04:59-05:00</updated>
  <id>http://btorpey.github.io/</id>
  <author>
    <name><![CDATA[Bill Torpey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building clang on RedHat]]></title>
    <link href="http://btorpey.github.io/blog/2015/01/02/building-clang/"/>
    <updated>2015-01-02T00:00:00-05:00</updated>
    <id>http://btorpey.github.io/blog/2015/01/02/building-clang</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/timallen.jpg" width="230" height="240" title="" >

clang is a great compiler, with a boatload of extremely helpful tools, including static analysis, run-time memory and data race analysis, and many others.  And it's apparently pretty easy to get those benefits on one of the supported platforms -- basically Ubuntu and Mac (via XCode).

That's fine, but if you get paid to write software, there's a good chance it's going to be deployed on RedHat, or one of its variants.  And, getting clang working on RedHat is a huge pain in the neck.  The good news is that I did the dirty work for you (ouch!), so you don't have to.

<!--more-->

<br>
Bootstrapping the compiler
--------------------------

Like almost all compilers, clang is written in a high-level language (in this case C++), so building clang requires a host compiler to do the actual compilation.  On Linux this is almost always gcc, since it is ubiquitous on Linux machines.  

There's a hitch, though -- as of version 3.3 some parts of clang are written in C++11, so the compiler used to compile clang needs to support the C++11 standard.

This is a real problem with RedHat, since the system compiler supplied with
RedHat 6 (the most recent version that is in wide use), is gcc 4.4.7.  That
compiler does not support C++11, and so is not able to compile clang.  So, the
first step is getting a C++11-compliant compiler so we can compile clang.  For
this example, we're going to choose gcc 4.8.2, for a variety of reasons[^5].  The
good news is that gcc 4.8.2 is written in C++ 98, so we can build it using the
system compiler (gcc 4.4.7).  

The next thing we have to decide is where to install gcc 4.8.2, and we basically have these choices:

-   We could install in /usr, where the new compiler would replace the system compiler.  Once we do that, though, we've effectively created a custom OS that will be required on all our development/QA/production machines going forward.  If "all our development/QA/production machines" == 1, this may not be a problem, but as the number increases things can get out of hand quickly. This approach also does not lend itself to being able to have more than one version of a particular package on a single machine, which is often helpful.

-   We could install in /usr/local (the default for gcc, and many other packages when built from source), so the new compiler would coexist with the system compiler.  The problem with this approach is that /usr/local can (and in practice often does) rapidly turn into a dumping-ground for miscellaneous executables and libraries.  Which wouldn't be so bad if we were diligent about keeping track of what they were and where they came from, but if we're going to do that we might as well ...

-   Install somewhere else -- it doesn't really matter where, as long as there's a convention. In this case, we're going to use the convention that any software that is not bundled with the OS gets installed in /build/share/\<package\>/\<version\>.  This approach makes it easy to know exactly what versions of what software we're running, since we need to specify its install directory explicitly in PATH and/or LD\_LIBRARY\_PATH.  It also makes it much easier to keep track of what everything is and where it came from.

Here's a script that will download gcc 4.8.2 along with its prerequisites, build it and install it as per the convention we just discussed:

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (build-gcc.sh)</span> <a href='/downloads/code/clang/build-gcc.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash </span>
</span><span class='line'><span class="nb">set</span> -exv
</span><span class='line'>
</span><span class='line'><span class="c">## modify the following as needed for your environment</span>
</span><span class='line'><span class="c"># location where gcc should be installed</span>
</span><span class='line'><span class="nv">INSTALL_PREFIX</span><span class="o">=</span>/build/share/gcc/4.8.2
</span><span class='line'><span class="c"># number of cores</span>
</span><span class='line'><span class="nv">CPUS</span><span class="o">=</span><span class="k">$(</span>nproc<span class="k">)</span>
</span><span class='line'><span class="c"># uncomment following to get verbose output from make</span>
</span><span class='line'><span class="c">#VERBOSE=VERBOSE=1</span>
</span><span class='line'><span class="c"># uncomment following if you need to sudo in order to do the install</span>
</span><span class='line'><span class="c">#SUDO=sudo</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c">## get everything</span>
</span><span class='line'>wget http://www.netgull.com/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.bz2
</span><span class='line'>wget https://gmplib.org/download/gmp/gmp-4.3.2.tar.bz2
</span><span class='line'>wget http://www.multiprecision.org/mpc/download/mpc-0.8.1.tar.gz
</span><span class='line'>wget http://www.mpfr.org/mpfr-2.4.2/mpfr-2.4.2.tar.bz2
</span><span class='line'>wget ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz
</span><span class='line'>wget ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.12.2.tar.bz2
</span><span class='line'>
</span><span class='line'><span class="c">## untar gcc</span>
</span><span class='line'>tar xf gcc-4.8.2.tar.bz2
</span><span class='line'><span class="c">## untar prereqs</span>
</span><span class='line'><span class="c"># gmp</span>
</span><span class='line'>tar xf gmp-4.3.2.tar.bz2
</span><span class='line'>mv gmp-4.3.2 gcc-4.8.2/gmp
</span><span class='line'><span class="c"># mpc</span>
</span><span class='line'>tar xf mpc-0.8.1.tar.gz
</span><span class='line'>mv mpc-0.8.1 gcc-4.8.2/mpc
</span><span class='line'><span class="c"># mpfr</span>
</span><span class='line'>tar xf mpfr-2.4.2.tar.bz2
</span><span class='line'>mv mpfr-2.4.2 gcc-4.8.2/mpfr
</span><span class='line'><span class="c"># cloog</span>
</span><span class='line'>tar xf cloog-0.18.1.tar.gz
</span><span class='line'>mv cloog-0.18.1 gcc-4.8.2/cloog
</span><span class='line'><span class="c"># isl</span>
</span><span class='line'>tar xf isl-0.12.2.tar.bz2
</span><span class='line'>mv isl-0.12.2 gcc-4.8.2/isl
</span><span class='line'>
</span><span class='line'><span class="c"># build gcc</span>
</span><span class='line'>rm -rf gcc
</span><span class='line'>mkdir gcc
</span><span class='line'><span class="nb">cd </span>gcc
</span><span class='line'>../gcc-4.8.2/configure --prefix<span class="o">=</span><span class="k">${</span><span class="nv">INSTALL_PREFIX</span><span class="k">}</span> --enable-languages<span class="o">=</span>c,c++ --disable-multilib
</span><span class='line'>make -j <span class="k">${</span><span class="nv">CPUS</span><span class="k">}</span> <span class="k">${</span><span class="nv">VERBOSE</span><span class="k">}</span>
</span><span class='line'><span class="c"># install it</span>
</span><span class='line'>rm -rf <span class="k">${</span><span class="nv">INSTALL_PREFIX</span><span class="k">}</span>
</span><span class='line'><span class="k">${</span><span class="nv">SUDO</span><span class="k">}</span> make install
</span></code></pre></td></tr></table></div></figure></notextile></div>

To run the script, change to an empty directory and then simply invoke the
script.  If you want to keep track of all the commands and output related to the
build, you can invoke the script using the trick I wrote about in an 
[earlier post](<http://btorpey.github.io/blog/2014/02/13/how-did-i-get-here/>).

Preparing to build
------------------

Now that we've built gcc, we can get started building clang[^1].  By default,
clang is built to use the C++ standard library (libstdc++) that is included with
gcc. That's the good news, since that means code generated using clang can be
intermixed freely with code generated with gcc -- which is almost all the code
on a typical Linux machine.

Finding the C++ standard library
--------------------------------

The libstdc++.so that is part of gcc is "versioned", which means that different library versions can have different symbols defined. Since we chose to install gcc 4.8.2 in a non-standard location, there are several settings that need to be tweaked to have code find and use that version of libstdc++[^4].

Let's start with a recap of how that works.

### Finding the C++ standard library at build-time

With a default installation of gcc, everything is easy: gcc itself is in /usr/bin, include files are in /usr/include (sort of), and library files are in /usr/lib and/or /usr/lib64. In cases where files are not installed in these locations, gcc itself keeps track of where it should look for dependencies, and the following command will show these locations:

    > g++ -E -x c++ - -v < /dev/null
    ...
    #include "..." search starts here:
    #include <...> search starts here:
     /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7
     /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux
     /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward
     /usr/lib/gcc/x86_64-redhat-linux/4.4.7/include
     /usr/include
    End of search list.
    ...
    LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/

With our non-standard installation of gcc 4.8.2, the same command shows the values appropriate for that version of the compiler:

    > /build/share/gcc/4.8.2/bin/g++ -E -x c++ - -v < /dev/null
    ...
    #include "..." search starts here:
    #include <...> search starts here:
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/include
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/include-fixed
     /shared/build/share/gcc/4.8.2/bin/../lib/gcc/../../include
     /usr/include
    ...
    LIBRARY_PATH=/shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/:/shared/build/share/gcc/4.8.2/bin/../lib/gcc/:/shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/shared/build/share/gcc/4.8.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../:/lib/:/usr/lib/

The situation with clang is a bit (!) more complicated. Not only does clang need
to be able to find its own include files and libraries, but it also needs to be
able to find the files for the compiler that clang is built with. In order
to successfully build clang with a non-standard compiler, we are going to need
to specify the following parameters to the clang build:

<table>
<col width="35%" />
<col width="60%" />
<tbody>
<tr class="odd">
<td align="left"><p>CMAKE_C_COMPILER</p></td>
<td align="left"><p>The location of the C compiler to use.</p></td>
</tr>
<tr class="even">
<td align="left"><p>CMAKE_CXX_COMPILER</p></td>
<td align="left"><p>The location of the C++ compiler to use.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>CMAKE_INSTALL_PREFIX</p></td>
<td align="left"><p>The location where the compiler should be installed.</p></td>
</tr>
<tr class="even">
<td align="left"><p>CMAKE_CXX_LINK_FLAGS</p></td>
<td align="left"><p>Additional flags to be passed to the linker for C++ programs.  See below for more information.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>GCC_INSTALL_PREFIX</p></td>
<td align="left"><p>Setting this parameter when building clang is equivalent to specifying the <code>--gcc-toolchain</code> parameter when invoking clang. See below for more information.</p></td>
</tr>
</tbody>
</table>

<br> 
While all these settings are documented in one place or another, as far as 
I know there is no single place that mentions them all.  (The clang developers apparently prefer writing code to writing
documentation ;-)  So, these settings have been cobbled together from a number
of sources (listed at the end of this article), and tested by much trial and
error.

The first three settings are plain-vanilla cmake settings, but the last two need some additional discussion:

### CMAKE\_CXX\_LINK\_FLAGS

In the clang build script this is set to `"-L${HOST_GCC}/lib64 -Wl,-rpath,${HOST_GCC}/lib64"`.  What this does is two-fold:

-   The `-L` parameter adds the following directory to the search path for the linker.  This is needed so the linker can locate the libraries installed with gcc 4.8.2.        

-   The `-Wl,-rpath,` parameter installs a ["run path"](<http://en.wikipedia.org/wiki/Rpath>) into any executables (including shared libraries) created during the build.  This is needed so any executables created can find their dependent libraries at run-time. 

    Note that you can display the run path for any executable (including shared libraries) with the following command:

        > objdump -x /build/share/clang/trunk/bin/clang++ | grep RPATH
        RPATH                /build/share/gcc/4.8.2/lib64:$ORIGIN/../lib

### GCC\_INSTALL\_PREFIX

Unfortunately, by default, clang looks for include and library files in the standard system locations (e.g., /usr), regardless of what compiler was used to build clang. (I filed a [bug report](http://llvm.org/bugs/show_bug.cgi?id=20510) for this behavior, but the clang developers apparently feel this is reasonable behavior. Reasonable people may disagree ;-)

The work-around for this is to specify GCC\_INSTALL\_PREFIX when building clang -- this tells the clang build where the gcc that is being used to build clang is located. Among other things, this determines where the clang compiler will look for system include and library files at compile and link time.

Building clang
--------------

Now that we have that out of the way, we can build clang. The following script will download clang source from svn, build and install it.
 
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (build-clang.sh)</span> <a href='/downloads/code/clang/build-clang.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nb">set</span> -exv
</span><span class='line'>
</span><span class='line'><span class="c">## modify the following as needed for your environment</span>
</span><span class='line'><span class="c"># location where clang should be installed</span>
</span><span class='line'><span class="nv">INSTALL_PREFIX</span><span class="o">=</span>/build/share/clang/trunk
</span><span class='line'><span class="c"># location of gcc used to build clang</span>
</span><span class='line'><span class="nv">HOST_GCC</span><span class="o">=</span>/build/share/gcc/4.8.2
</span><span class='line'><span class="c"># number of cores</span>
</span><span class='line'><span class="nv">CPUS</span><span class="o">=</span><span class="k">$(</span>nproc<span class="k">)</span>
</span><span class='line'><span class="c"># uncomment following to get verbose output from make</span>
</span><span class='line'><span class="c">#VERBOSE=VERBOSE=1</span>
</span><span class='line'><span class="c"># uncomment following if you need to sudo in order to do the install</span>
</span><span class='line'><span class="c">#SUDO=sudo</span>
</span><span class='line'>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c"># gets clang tree from svn into ./llvm</span>
</span><span class='line'><span class="c"># params (e.g., -r) can be specified on command line</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'>rm -rf llvm
</span><span class='line'><span class="c">## get everything</span>
</span><span class='line'><span class="c"># llvm</span>
</span><span class='line'>svn co <span class="nv">$*</span> http://llvm.org/svn/llvm-project/llvm/trunk llvm
</span><span class='line'><span class="c"># clang</span>
</span><span class='line'><span class="nb">cd </span>llvm/tools
</span><span class='line'>svn co <span class="nv">$*</span> http://llvm.org/svn/llvm-project/cfe/trunk clang
</span><span class='line'><span class="nb">cd</span> -
</span><span class='line'><span class="c"># extra</span>
</span><span class='line'><span class="nb">cd </span>llvm/tools/clang/tools
</span><span class='line'>svn co <span class="nv">$*</span> http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
</span><span class='line'><span class="nb">cd</span> -
</span><span class='line'><span class="c"># compiler-rt</span>
</span><span class='line'><span class="nb">cd </span>llvm/projects
</span><span class='line'>svn co <span class="nv">$*</span> http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt
</span><span class='line'><span class="nb">cd</span> -
</span><span class='line'>
</span><span class='line'><span class="c">## build clang w/gcc installed in non-standard location</span>
</span><span class='line'>rm -rf clang
</span><span class='line'>mkdir -p clang
</span><span class='line'><span class="nb">cd </span>clang
</span><span class='line'>cmake -DCMAKE_C_COMPILER<span class="o">=</span><span class="k">${</span><span class="nv">HOST_GCC</span><span class="k">}</span>/bin/gcc -DCMAKE_CXX_COMPILER<span class="o">=</span><span class="k">${</span><span class="nv">HOST_GCC</span><span class="k">}</span>/bin/g++ -DGCC_INSTALL_PREFIX<span class="o">=</span><span class="k">${</span><span class="nv">HOST_GCC</span><span class="k">}</span> -DCMAKE_CXX_LINK_FLAGS<span class="o">=</span><span class="s2">&quot;-L${HOST_GCC}/lib64 -Wl,-rpath,${HOST_GCC}/lib64&quot;</span> -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="k">${</span><span class="nv">INSTALL_PREFIX</span><span class="k">}</span> -DLLVM_ENABLE_ASSERTIONS<span class="o">=</span>ON -DCMAKE_BUILD_TYPE<span class="o">=</span><span class="s2">&quot;Release&quot;</span> -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;X86&quot;</span> ../llvm
</span><span class='line'>make -j <span class="k">${</span><span class="nv">CPUS</span><span class="k">}</span> <span class="k">${</span><span class="nv">VERBOSE</span><span class="k">}</span>
</span><span class='line'><span class="c"># install it</span>
</span><span class='line'>rm -rf <span class="k">${</span><span class="nv">INSTALL_PREFIX</span><span class="k">}</span>
</span><span class='line'><span class="k">${</span><span class="nv">SUDO</span><span class="k">}</span> make install
</span></code></pre></td></tr></table></div></figure></notextile></div>

Note that you can specify a parameter to the script (e.g., `-r 224019`) to get a specific version of clang from svn.

Building using clang
--------------------

At this point, we should have a working clang compiler that we can use to build and run our own code. But once again, because the "host" gcc (and libstdc++) are installed in a non-standard location, we need to tweak a couple of build settings to get a successful build.

### Specifying the compiler to use

There are a bunch of ways to specify the compiler, depending on what build system you're using -- I'll mention a couple of them here.

If you're using make, you can prefix the make command as follows:

    CC=clang CXX=clang++ make ... 

If you're using cmake you can [specify the compiler to use](http://www.cmake.org/Wiki/CMake_FAQ#How_do_I_use_a_different_compiler.3F) on the cmake command line, as follows:

    cmake -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ ... 

Personally, I find that ridiculously inconvenient, so in my CMakeLists.txt file I specify the compiler directly:

    # cmake doc says this is naughty, but their suggestions are even worse...
    if("$ENV{COMPILER}" STREQUAL "gcc")
      set(CMAKE_C_COMPILER      gcc)
      set(CMAKE_CXX_COMPILER    g++)
    elseif("$ENV{COMPILER}" STREQUAL "clang")
      set(CMAKE_C_COMPILER      clang)
      set(CMAKE_CXX_COMPILER    clang++)
    endif()

In any of the above, you can either specify the full path to the compiler, or just specify the name of the compiler executable (as above), and make sure that the executable is on your PATH.

Last but not least, if you're using GNU autotools -- you're on your own, good luck! The only thing I want to say about autotools is that [I agree with this guy](https://twitter.com/timmartin2/status/23365017839599616).

### Finding the C++ standard library at run-time

Any code genrated using clang is also going to need to be able to find the libraries that clang was built with at run-time. There are a couple of ways of doing that:

-   Similar to what we did above when building clang, you can specify the `-Wl,-rpath,` parameter to the linker to set a run path for your executables.
     Note that if you're using cmake, it will [automatically strip the rpath](<http://www.cmake.org/Wiki/CMake_RPATH_handling>) from all files when running `make install`, so you may need to disable that by setting `CMAKE_SKIP_INSTALL_RPATH` to false in your build.

-   Alternatively, you will need to make sure that the proper library directory is on your `LD_LIBRARY_PATH` at run-time[^3].

##So, What Could Possibly Go Wrong?

If you've followed the directions above, you should be good to go, but be warned that, just like in "Harry Potter", messing up any part of the spell can cause things to go spectacularly wrong. Here are a few examples:

-   If you try to use the system compiler (gcc 4.4.7) to build clang, you'll get an error like the following:

<!-- -->

    CMake Error at cmake/modules/HandleLLVMOptions.cmake:17 (message):
      Host GCC version must be at least 4.7!

-   The clang build executes code, that was built with clang, as part of the build step. If clang can't find the correct (i.e., gcc 4.8.2) version of libstdc++ at build time, you will see an error similar to the following:

<!-- -->

    Linking CXX static library ../../../../lib/libclangAnalysis.a
    [ 51%] Built target clangAnalysis
    [ 51%] Building CXX object tools/clang/lib/Sema/CMakeFiles/clangSema.dir/SemaConsumer.cpp.o
    [ 51%] Building CXX object tools/clang/lib/ARCMigrate/CMakeFiles/clangARCMigrate.dir/TransAutoreleasePool.cpp.o
    [ 51%] Building CXX object tools/clang/lib/AST/CMakeFiles/clangAST.dir/ExprConstant.cpp.o
    Scanning dependencies of target ClangDriverOptions
    [ 51%] Building Options.inc...
    ../../../../../bin/llvm-tblgen: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15' not found (required by ../../../../../bin/llvm-tblgen)

-   If you build clang without specifying the `-Wl,-rpath` parameter, clang won't be able to find the libraries it needs at compile-time:

<!-- -->

    > clang++ $* hello.cpp && ./a.out
    clang++: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14' not found (required by clang++)
    clang++: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18' not found (required by clang++)
    clang++: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15' not found (required by clang++)

-   If the GCC\_INSTALL\_PREFIX setting isn't specified when you build with clang, it will look for system files in /usr, rather than the proper directory, and you will see something like this:

<!-- -->

    > clang++ $* hello.cpp && ./a.out
    In file included from hello.cpp:1:
    In file included from /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/iostream:40:
    In file included from /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ostream:40:
    In file included from /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ios:40:
    In file included from /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/exception:148:
    /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/exception_ptr.h:143:13: error: unknown type name 'type_info'
          const type_info*
                ^
    1 error generated.

I've probably missed a couple, but you get the idea.

Conclusion
----------

There may be another way to build clang successfully on a RH-based system, but
if there is I've yet to discover it. As mentioned earlier, bits and pieces of
this information have been found in other sources, including the following:

<http://llvm.org/docs/GettingStarted.html#getting-a-modern-host-c-toolchain>

<http://clang-developers.42468.n3.nabble.com/getting-clang-to-find-non-default-libstdc-td3945163.html>

<https://code.google.com/p/memory-sanitizer/wiki/BuildingClangOnOlderSystems>

<http://llvm.org/docs/CMake.html>
 

[^1]: You will need at least version 2.8 of cmake to do the build, which is not native on RH/CentOS 6.  That version can be installed using "Add/Remove Software" or yum.  (Or, of course, you can build it from source).

[^3]: This is the approach we use in my shop -- we have a hard-and-fast rule that application code cannot contain a run path, and we deliberately strip any existing RPATH entries from code that is being deployed to QA and production as a security measure.

[^4]: I may go into more detail on this in a later post, but in the meantime if you're interested you should consult Ulrich Drepper's "How to Write Shared Libraries" at http://www.akkadia.org/drepper/dsohowto.pdf.

[^5]: One reason is that gcc 4.9.0 can't compile libc++, the llvm version of the C++ standard library -- see <http://lists.cs.uiuc.edu/pipermail/cfe-dev/2014-April/036669.html> for more detail.  While we're not going to discuss using libc++ in this post, we may get into that later on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repent, Sinner!]]></title>
    <link href="http://btorpey.github.io/blog/2014/09/21/repent/"/>
    <updated>2014-09-21T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/09/21/repent</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/nun-with-ruler.jpg" width="240" height="160"> 

When I was a kid I went to Catholic school, and back in those days 
the nuns would indeed rap your knuckles with a ruler if you
misbehaved. That doesn't happen so much any more, but when I see someone 
making use of the [copy-paste anti-pattern](http://c2.com/cgi/wiki?CopyAndPasteProgramming), 
I'm tempted to reach for a ruler myself. 
(I know, probably not a good career move ;-)

Short of rapping someone's knuckles with a ruler, though, how do you show some poor sinner the error of his ways?

<!--more-->

Enter [CPD, or copy-paste detector](http://pmd.sourceforge.net/pmd-5.1.3/cpd-usage.html). 
This does pretty much what you would guess from its name -- it
spins through all the code you give it, and analyzes it for repeated sequences.
[^1]

Here's an example of running the GUI version against the code I used 
in an [earlier post](http://btorpey.github.io/blog/2014/02/12/shared-singletons/) on smart pointers.

<img class="right" src="/images/cpd.png">

(Note that the "Ignore literals" and "Ignore identifiers" checkboxes are
disabled if you select C++ as the language - these options [are only implemented for Java currently](http://sourceforge.net/p/pmd/discussion/188193/thread/91553283)).

The site has several more examples, but [this one](http://pmd.sourceforge.net/pmd-5.1.3/cpdresults.txt) just blew my mind -- 
hard to imagine how anyone could write this code in
the first place, much less be so confident that it is correct that they just
copy and paste it in two different files (with nary a comment to tie the two
together)?

<pre>
=====================================================================
Found a 19 line (329 tokens) duplication in the following files: 
Starting at line 685 of /usr/local/java/src/java/util/BitSet.java
Starting at line 2270 of /usr/local/java/src/java/math/BigInteger.java
    static int bitLen(int w) {
        // Binary search - decision tree (5 tests, rarely 6)
        return
         (w < 1<<15 ?
          (w < 1<<7 ?
           (w < 1<<3 ?
            (w < 1<<1 ? (w < 1<<0 ? (w<0 ? 32 : 0) : 1) : (w < 1<<2 ? 2 : 3)) :
            (w < 1<<5 ? (w < 1<<4 ? 4 : 5) : (w < 1<<6 ? 6 : 7))) :
           (w < 1<<11 ?
            (w < 1<<9 ? (w < 1<<8 ? 8 : 9) : (w < 1<<10 ? 10 : 11)) :
            (w < 1<<13 ? (w < 1<<12 ? 12 : 13) : (w < 1<<14 ? 14 : 15)))) :
          (w < 1<<23 ?
           (w < 1<<19 ?
            (w < 1<<17 ? (w < 1<<16 ? 16 : 17) : (w < 1<<18 ? 18 : 19)) :
            (w < 1<<21 ? (w < 1<<20 ? 20 : 21) : (w < 1<<22 ? 22 : 23))) :
           (w < 1<<27 ?
            (w < 1<<25 ? (w < 1<<24 ? 24 : 25) : (w < 1<<26 ? 26 : 27)) :
            (w < 1<<29 ? (w < 1<<28 ? 28 : 29) : (w < 1<<30 ? 30 : 31)))));
    }

</pre>

So, if you need to lead someone to the light, try PMD's copy-paste detector.  It
may hurt a bit, but a lot less than a sharp rap on the knuckles!

One last caveat about CPD: it does not like symlinks at all -- you must give it the real path names for any source files, or
you will just get a bunch of "Skipping ... since it appears to be a symlink" messages.


[^1]: CPD is part of the [PMD tool](http://pmd.sourceforge.net/pmd-5.1.3/), which can do a lot of useful things with Java code. But since I'm primarily dealing with C++ code these days (and because duplicate code is such a hot-button issue for me), CPD is the part that I use.
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guess What Day It Is!]]></title>
    <link href="http://btorpey.github.io/blog/2014/07/23/perl-stdin/"/>
    <updated>2014-07-23T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/07/23/perl-stdin</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/phl.pm.org-camel.png" width="320" height="240"> 

No, not that -- it's Perl day.  (Well, actually it's just Wednesday, but you get the idea).

Sometimes it seems that everybody likes to hate on Perl, but I think their
animus is misdirected. It's not Perl that's the problem, it's those \^\\\$\(\.\#\!\)?$
regular expressions.

Or, as Jamie Zawinski once said 
["Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems."](http://en.wikiquote.org/wiki/Jamie_Zawinski).

Well, I'm here to tell you that it's possible to write whole Perl programs that
actually accomplish useful work,* without any regular expressions at all!* And, if you do
that, you can actually *read the code!*

It turns out that Perl is a dandy scripting language, and while some may take issue
with its flexibility ("There's more than one way to do it"), others (including me) find that flexibility very useful.

<!--more-->

One example of that flexibility is how easy it is to create a Perl program that
can read input either from stdin, or from a file specified on the command line.

    local *INFILE;
    if (defined($ARGV[0])) {
        open(INFILE, "<:crlf", "$ARGV[0]") or die "Cant open $ARGV[0]\n";
    }
    else {
        *INFILE = *STDIN;
    }

    while (<INFILE>) {
    }

    close(INFILE);

The above snippet does just that, and also works well with command-line parsers
(e.g., `GetOpt`) that eat their parameters by removing them from the ARGV
array.


</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where Am I?]]></title>
    <link href="http://btorpey.github.io/blog/2014/05/29/where-am-i/"/>
    <updated>2014-05-29T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/05/29/where-am-i</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/gilligans-island-tv-show.jpg" width="320" height="240"> 

From *Robinson Crusoe* to *Gilligan's Island* to *Lost*, tales of being
stranded on a desert island seem to resonate with people in a special way. Some
of that likely has to do with the exotic locales, and the practical challenges
of getting water, food and shelter.

But an even more basic part is the unanswered question: "Where am I?" that makes
things so -- well, *mysterious*.

Shell scripting can be pretty mysterious too at times, but in this installment
we'll learn how to answer that basic question of "Where am I?" to make shell
scripting a little less mysterious.

<!--more-->

One of the tenets of the Unix way is brevity, and one consequence of that is
that well-behaved programs should be able to find whatever other resources they
need without having to be told where they are. Windows attempts to
solve this problem with the (gack!) registry, but Unix tends to use a simpler
approach: needed resources are placed either in well-known locations (e.g., /etc
for system programs), or where they can be found relative to the location of the
program itself.

Another attribute of a well-behaved Unix program is that it
should be able to run from any location, whether it's invoked with a full path,
or found via the PATH variable.

So, how do we reconcile those two requirements? And specifically, how do we do
that in shell scripts? Since -- regardless of what your "main" language is, if
you're programming in Unix/Linux, you're probably also writing a boatload of
shell scripts too.

It turns out that, at least in bash, there is a
simple but non-obvious way to do get the location of the script file itself,
which goes something like this:

    SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE}) && /bin/pwd) 

Let's follow this through and see how it works:

-   The `$( ... )` construct invokes a sub-shell. This is handy since it
allows us to change the environment of the sub-shell (e.g., current directory)
without affecting the current environment.

-   `$BASH_SOURCE` is a builtin variable that gives us the path to the shell
script itself. For instance, if we invoke a script with `./scriptname.sh`,
then that's what will end up in `${BASH_SOURCE}`.

-   To get the full path then we extract just the path part with `dirname`, again
in a sub-shell.

-   We then `cd` into that directory, and if successful get the full pathname
with `/bin/pwd`.
    -   Note that we use `/bin/pwd` to get the path. This version resolves any
    symbolic links to return the actual physical path. There is also a `pwd`
    built-in to bash, but that one does not expand symbolic links by default.
<br>
-   Finally, the result is assigned to SCRIPT_DIR.

We now have the full path of the script file itself, and can use that to locate
any other resources needed by the script. For a real-world example, you can
check out the [these scripts](<https://github.com/btorpey/latency-utils.git>) from
 [my earlier post on visualizing latency](</blog/2014/05/16/visualizing-latency/>).


</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualizing Latency]]></title>
    <link href="http://btorpey.github.io/blog/2014/05/16/visualizing-latency/"/>
    <updated>2014-05-16T00:00:00-04:00</updated>
    <id>http://btorpey.github.io/blog/2014/05/16/visualizing-latency</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/ping.png" width="320" height="240"> 

I'm a visual thinker (I think I may have [mentioned that before](http://btorpey.github.io/blog/2014/04/29/a-picture-is-worth-1k-words/) ),
so when I'm analyzing performance, latency, etc. I find it really helpful to be
able to visualize what is going on on the machine. 

As a result, I had gotten
reasonably good at using Excel to produce charts, which sometimes helped to correlate observed
behaviors like latency spikes with other events on the machine.

For a bunch of reasons I wanted to move away from Excel, though, and find
another tool that would give me the same or better functionality.

<!--more-->

For one thing, a little over a year ago I switched to a Mac as my main machine
after years of using Windows. There was a certain amount of adjustment, but for
the most part it's been smooth sailing. More than that, I was actually able to
recapture some of the fun and excitement I remember from my first Apple (an
Apple ][).

I also wanted something that would run on both the Mac and Linux, where I do
most of my testing. Last but not least, I wanted something that would be
scriptable so I could easily produce consistent charts for multiple test runs.

I looked briefly at R, but ditched it when it used up all the 8GB in my laptop,
plus the entire hard disk as swap, for a single dataset of 100,000 points.
Probably my bad, but I didn't have the patience to figure out what I might be
doing wrong.

At that point I turned to venerable (some would say crusty) gnuplot. It's a bit
long in the tooth, but I just wanted to plot latency over time, so how hard
could that be? Well, I guess it's pretty easy if you already know how, but
starting from scratch is another story.

Which brings me to my rant of the day, directed at techies in general, and to the
(us?) Linux/Unix techies in particular.

Short version: I don't want to learn gnuplot. I don't even want to *have
learned* gnuplot -- even if I could do that by just taking a pill. What I want
is to be able to produce decent-looking charts *without* knowing *anything*
about gnuplot.

To be fair, the gnuplot docs did have some examples -- more anyway than you
would find in a typical man page, although that's admittedly a low bar. And
while my google-fu is usually pretty good, I just couldn't find anything on the
intertubes that would work for me, so I had to learn *just a little* gnuplot.

> When all else fails, read the instructions.

It turns out that gnuplot works pretty well, and will probably work even better
once I learn (sigh) how to use it better.

But you don't have to learn diddly if you don't want to. [Here is the first](<https://github.com/btorpey/latency-utils.git>) in
what will hopefully be a series of recipes that you can use with little or no
modification.  Once you've downloaded the repo, enter the following at the command prompt:

`./tsd.sh ping.csv x11`

Which should result in something like this:

<img class="center" src="/images/gnuplot.png"> 

It's primitive, but that very primitiveness has its own appeal, especially for
those of us for whom "UI" means bash, vi or emacs.

A couple of points about the gnuplot command files:

-   Sometimes you care about the actual time that an event took place, so you
can correlate it with some other event; sometimes you don't. Accordingly, I've
created two different files: one which displays actual time (ts.gp), the other
which calculates and displays deltaT (tsd.gp).

-   I've been programming in C (and later C++) for many years, but I don't think
I've ever purposely used the comma operator before. Well, expressions in gnuplot
follow C language rules for operators, precedence, etc. and that comma operator
turns out to be handy -- in this case it lets us 
update the origin in the same expression that calculates deltaT.
(The return value of the comma
operator is the right-hand expression).

-- (Note that the above requires something like gnuplot 4.6)


-   I've left the default terminal in the gnuplot command files, but you can 
specify a different one on the command line.  To get a list of terminals supported 
in your version:
`gnuplot -e "set terminal"`.

Comments, suggestions, pull requests, etc. welcome.</p>
]]></content>
  </entry>
  
</feed>
